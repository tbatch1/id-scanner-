<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=yes, maximum-scale=5.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>THC Club | Age Verified Checkout</title>
    <script src="https://unpkg.com/@zxing/library@latest"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #111;
            color: #f5f5f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background: #181818;
            padding: 18px 32px;
            border-bottom: 2px solid #0d6efd;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            font-size: 15px;
            color: #a5a5a5;
        }

        main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        aside {
            width: 340px;
            background: #161616;
            border-right: 1px solid #222;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.1px;
            color: #9b9b9b;
        }

        select {
            width: 100%;
            margin-top: 6px;
            margin-bottom: 12px;
            background: #202020;
            color: #f5f5f5;
            border: 1px solid #2f2f2f;
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 14px;
        }

        .sale-summary h2 {
            font-size: 18px;
            margin-bottom: 12px;
        }

        .sale-lines {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .sale-line {
            background: #1f1f1f;
            border-radius: 8px;
            padding: 12px;
        }

        .sale-line-title {
            font-weight: 600;
            font-size: 15px;
        }

        .sale-line-meta {
            font-size: 13px;
            color: #b5b5b5;
            margin-top: 4px;
        }

        .status-card,
        .camera-card {
            background: #1f1f1f;
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .status-pill {
            align-self: flex-start;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 13px;
            background: #343434;
            color: #d8d8d8;
        }

        .status-pill.approved {
            background: rgba(13, 110, 253, 0.2);
            color: #74b4ff;
        }

        .status-pill.flagged {
            background: rgba(220, 53, 69, 0.24);
            color: #ff8a8a;
        }

        .status-message {
            font-size: 15px;
            line-height: 1.4;
            color: #c9c9c9;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-hint {
            font-size: 13px;
            color: #9b9b9b;
        }

        .diagnostics {
            background: #1f1f1f;
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .diagnostics h3 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .diagnostics-status {
            font-size: 14px;
            color: #c9c9c9;
        }

        .diagnostics-log {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .diagnostics-log li {
            color: #a5a5a5;
            padding: 2px 0;
        }

        .diagnostics-log li.diag-error {
            color: #ff7a7a;
        }

        .diagnostics-log li.diag-warn {
            color: #ffd479;
        }

        .diagnostics-log li.diag-info {
            color: #8dd6ff;
        }

        .diagnostics-log li.diag-debug {
            color: #bdbdbd;
        }

        .actions {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            border: none;
            border-radius: 8px;
            padding: 14px 18px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s ease, opacity 0.1s ease;
        }

        button.primary {
            background: #0d6efd;
            color: white;
        }

        button.secondary {
            background: #2b2b2b;
            color: #f5f5f5;
        }

        button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        button:not(:disabled):active {
            transform: scale(0.98);
        }

        section.scanner {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #scanner-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: black;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #overlay {
            position: absolute;
            width: 78%;
            max-width: 480px;
            height: 220px;
            border: 3px solid rgba(13, 110, 253, 0.8);
            border-radius: 12px;
            pointer-events: none;
        }

        #overlay::before,
        #overlay::after {
            content: '';
            position: absolute;
            left: 8%;
            right: 8%;
            height: 2px;
            background: rgba(13, 110, 253, 0.55);
        }

        #overlay::before {
            top: 32%;
        }

        #overlay::after {
            bottom: 32%;
        }

        #flash-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.6);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        #flash-overlay.show {
            opacity: 1;
        }

        .shutter-bar {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 10;
        }

        .shutter-button {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.65);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(6px);
            cursor: pointer;
            transition: transform 0.1s ease, background 0.1s ease;
        }

        .shutter-button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.35);
        }

        #instruction {
            position: absolute;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 15, 0.88);
            padding: 16px 28px;
            border-radius: 10px;
            font-size: 16px;
        }

        #result {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            padding: 40px;
            text-align: center;
        }

        #result.show {
            display: flex;
        }

        .result-card {
            background: #1b1b1b;
            border-radius: 16px;
            padding: 32px 42px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.4);
            max-width: 540px;
            width: 100%;
        }

        #capture-preview {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.94);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 32px;
            gap: 24px;
            z-index: 100;
        }

        #capture-preview.show {
            display: flex;
        }

        .preview-card {
            background: #1b1b1b;
            border-radius: 16px;
            padding: 24px;
            width: min(90vw, 480px);
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.45);
        }

        #preview-image {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        }

        .preview-actions {
            display: flex;
            justify-content: space-between;
            gap: 16px;
        }

        .preview-status {
            font-size: 15px;
            color: #c9c9c9;
            min-height: 20px;
            text-align: center;
        }

        .age-status {
            font-size: 56px;
            font-weight: 700;
            margin-bottom: 20px;
            border-radius: 12px;
            padding: 18px;
        }

        .age-status.approved {
            background: #198754;
            color: #e8fff1;
        }

        .age-status.denied {
            background: #dc3545;
            color: #ffecec;
        }

        .info {
            font-size: 20px;
            line-height: 1.5;
        }

        .info-label {
            color: #a5a5a5;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.4px;
        }

        .toast {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 14px 22px;
            border-radius: 10px;
            font-size: 15px;
            display: none;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
        }

        .toast.show {
            display: inline-flex;
        }

        @media (max-width: 980px) {
            body {
                height: auto;
                min-height: 100vh;
                overflow-y: auto;
            }

            main {
                flex-direction: column;
                min-height: calc(100vh - 120px);
            }

            aside {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #222;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .actions {
                width: 100%;
                flex-direction: row;
            }

            section.scanner {
                min-height: 420px;
            }

            #scanner-container {
                min-height: 420px;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Age Verified Checkout</h1>
        <div class="meta">
            <span id="sale-label">Sale: --</span>
            <span id="total-label">Total: --</span>
            <span id="clerk-label">Clerk: --</span>
            <span id="status-label">Status: Awaiting scan</span>
        </div>
    </header>
    <main>
        <aside>
            <section class="sale-summary">
                <h2>Current Sale</h2>
                <div class="sale-lines" id="sale-lines"></div>
            </section>
            <section class="status-card">
                <span class="status-pill" id="verification-pill">Not verified</span>
                <p class="status-message" id="status-message">
                    Hold the ID 4-6 inches from the camera. Keep the PDF417 barcode inside the blue frame and avoid glare.
                </p>
            </section>
            <section class="camera-card">
                <div>
                    <label for="camera-select">Camera</label>
                    <select id="camera-select"></select>
                </div>
                <div class="control-buttons">
                    <button class="secondary" id="refresh-cameras" type="button">Refresh cameras</button>
                    <button class="secondary" id="capture-frame" type="button">Capture Photo</button>
                    <button class="secondary" id="fallback-capture" type="button" style="display: none;">Use Native Camera</button>
                    <input type="file" id="fallback-input" accept="image/*" capture="environment" style="display: none;">
                </div>
                <p class="control-hint">
                    Tip: pinch with two fingers to zoom. Tap the shutter button for a manual capture if needed.
                </p>
            </section>
            <section class="diagnostics">
                <h3>Scanner Status</h3>
                <div class="diagnostics-status" id="diagnostics-status">Initializing...</div>
                <ul class="diagnostics-log" id="diagnostics-log"></ul>
            </section>
            <div class="actions">
                <button class="primary" id="complete-sale" disabled>Complete Sale</button>
                <button class="secondary" id="restart-scan">Restart Scan</button>
            </div>
        </aside>
        <section class="scanner">
            <div id="scanner-container">
                <video id="video" autoplay muted playsinline webkit-playsinline></video>
                <div id="overlay"></div>
                <div id="flash-overlay"></div>
                <div id="instruction">Align the barcode between the guide lines</div>
                <div id="result">
                    <div class="result-card">
                        <div id="age-status" class="age-status">Scanning...</div>
                        <div class="info">
                            <div class="info-label">Customer</div>
                            <div id="name">--</div>
                        </div>
                        <div class="info">
                            <div class="info-label">Date of Birth</div>
                            <div id="dob">--</div>
                        </div>
                        <div class="info">
                            <div class="info-label">Calculated Age</div>
                            <div id="age">--</div>
                        </div>
                        <button class="secondary" id="scan-again" type="button">Scan Another ID</button>
                    </div>
                </div>
                <div id="capture-preview" aria-hidden="true">
                    <div class="preview-card">
                        <img id="preview-image" alt="Captured ID preview">
                        <div class="preview-actions">
                            <button class="secondary" id="preview-retake" type="button">Retake</button>
                            <button class="primary" id="preview-confirm" type="button">Use Photo</button>
                        </div>
                        <p class="preview-status" id="preview-status"></p>
                    </div>
                </div>
                <div class="shutter-bar">
                    <button class="shutter-button" id="shutter-button" type="button" aria-label="Capture snapshot"></button>
                </div>
            </div>
        </section>
    </main>
    <div class="toast" id="toast"></div>
    <script>
    (function () {
        'use strict';

        const codeReader = new ZXing.BrowserPDF417Reader();

        const ui = {
            video: document.getElementById('video'),
            resultOverlay: document.getElementById('result'),
            capturePreview: document.getElementById('capture-preview'),
            previewImage: document.getElementById('preview-image'),
            previewRetakeBtn: document.getElementById('preview-retake'),
            previewConfirmBtn: document.getElementById('preview-confirm'),
            previewStatus: document.getElementById('preview-status'),
            flashOverlay: document.getElementById('flash-overlay'),
            shutterButton: document.getElementById('shutter-button'),
            scanAgainBtn: document.getElementById('scan-again'),
            restartScanBtn: document.getElementById('restart-scan'),
            completeSaleBtn: document.getElementById('complete-sale'),
            refreshCamerasBtn: document.getElementById('refresh-cameras'),
            captureFrameBtn: document.getElementById('capture-frame'),
            fallbackCaptureBtn: document.getElementById('fallback-capture'),
            fallbackInput: document.getElementById('fallback-input'),
            cameraSelect: document.getElementById('camera-select'),
            toast: document.getElementById('toast'),
            overlayBox: document.getElementById('overlay'),
            saleLabel: document.getElementById('sale-label'),
            totalLabel: document.getElementById('total-label'),
            clerkLabel: document.getElementById('clerk-label'),
            statusLabel: document.getElementById('status-label'),
            verificationPill: document.getElementById('verification-pill'),
            statusMessage: document.getElementById('status-message'),
            saleLinesContainer: document.getElementById('sale-lines'),
            ageStatusDiv: document.getElementById('age-status'),
            nameDiv: document.getElementById('name'),
            dobDiv: document.getElementById('dob'),
            ageDiv: document.getElementById('age'),
            diagnosticsStatus: document.getElementById('diagnostics-status'),
            diagnosticsLog: document.getElementById('diagnostics-log')
        };

        const urlParams = new URLSearchParams(window.location.search);
        const state = {
            saleId: urlParams.get('saleId') || 'SALE-1001',
            clerkId: urlParams.get('clerkId') || 'demo-clerk',
            apiBase: (() => {
                const apiOverride = urlParams.get('api');
                const defaultApiBase = window.location.protocol === 'file:'
                    ? 'http://localhost:4000/api'
                    : `${window.location.origin}/api`;
                return apiOverride || defaultApiBase;
            })(),
            availableDevices: [],
            activeDeviceId: null,
            currentStream: null,
            activeVideoTrack: null,
            isScanning: false,
            isProcessing: false,
            zoomCapability: null,
            currentZoomValue: 1,
            activePointers: new Map(),
            pinchState: null,
            lastCaptureDataUrl: null
        };

        const LOG_ENDPOINT = `${state.apiBase}/logs`;
        const MAX_LOG_ENTRIES = 12;

        function sendLog(entry) {
            fetch(LOG_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(entry)
            }).catch(() => {});
        }

        function appendDiagnostic(entry) {
            if (!ui.diagnosticsLog) return;
            const item = document.createElement('li');
            item.className = `diag-${entry.level}`;
            const time = new Date(entry.timestamp).toLocaleTimeString();
            item.textContent = `${time} | ${entry.message}`;
            ui.diagnosticsLog.prepend(item);
            while (ui.diagnosticsLog.childNodes.length > MAX_LOG_ENTRIES) {
                ui.diagnosticsLog.removeChild(ui.diagnosticsLog.lastChild);
            }
            if (ui.diagnosticsStatus) {
                ui.diagnosticsStatus.textContent = entry.message;
            }
        }

        function logEvent(level, message, meta = {}) {
            const entry = {
                timestamp: new Date().toISOString(),
                level,
                message,
                meta: Object.assign({
                    saleId: state.saleId,
                    clerkId: state.clerkId,
                    activeDeviceId: state.activeDeviceId
                }, meta)
            };

            try {
                appendDiagnostic(entry);
                const consoleFn = level === 'error' ? console.error : level === 'warn' ? console.warn : console.log;
                consoleFn(`[scanner] ${message}`, entry.meta);
                sendLog(entry);
            } catch (err) {
                console.error('Log processing failed', err);
            }
        }

        function showFallbackButtons(show) {
            if (!ui.fallbackCaptureBtn) return;
            ui.fallbackCaptureBtn.style.display = show ? 'inline-flex' : 'none';
        }

        function showToast(message, variant = 'error') {
            if (!ui.toast) return;
            ui.toast.textContent = message;
            ui.toast.style.background = variant === 'error'
                ? 'rgba(220, 53, 69, 0.9)'
                : variant === 'warn'
                    ? 'rgba(255, 193, 7, 0.9)'
                    : 'rgba(13, 110, 253, 0.9)';
            ui.toast.classList.add('show');
            setTimeout(() => ui.toast.classList.remove('show'), 3200);
        }

        function setVerificationState(stateText, message) {
            if (ui.verificationPill) {
                ui.verificationPill.textContent = stateText;
                ui.verificationPill.classList.remove('approved', 'flagged');
                if (stateText === 'Approved') {
                    ui.verificationPill.classList.add('approved');
                } else if (stateText === 'Flagged') {
                    ui.verificationPill.classList.add('flagged');
                }
            }
            if (ui.statusMessage) {
                ui.statusMessage.textContent = message;
            }
            logEvent('info', message, { verificationState: stateText });
        }

        function renderSaleLines(sale) {
            if (!ui.saleLinesContainer) return;
            ui.saleLinesContainer.innerHTML = '';
            sale.items.forEach((line) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'sale-line';
                wrapper.innerHTML = `
                    <div class="sale-line-title">${line.description}</div>
                    <div class="sale-line-meta">Qty ${line.quantity} | ${sale.currency || 'USD'} ${line.price.toFixed(2)}</div>
                `;
                ui.saleLinesContainer.appendChild(wrapper);
            });
        }

        function calculateAge(dobString) {
            if (!dobString || dobString.length < 8) {
                return null;
            }

            let month;
            let day;
            let year;

            if (dobString.length === 8) {
                const monthCandidate = parseInt(dobString.substring(0, 2), 10);
                if (monthCandidate > 12) {
                    year = parseInt(dobString.substring(0, 4), 10);
                    month = parseInt(dobString.substring(4, 6), 10);
                    day = parseInt(dobString.substring(6, 8), 10);
                } else {
                    month = monthCandidate;
                    day = parseInt(dobString.substring(2, 4), 10);
                    year = parseInt(dobString.substring(4, 8), 10);
                }
            } else if (dobString.includes('-')) {
                const parts = dobString.split('-');
                year = parseInt(parts[0], 10);
                month = parseInt(parts[1], 10);
                day = parseInt(parts[2], 10);
            } else {
                return null;
            }

            if ([month, day, year].some((value) => Number.isNaN(value))) {
                return null;
            }

            const dob = new Date(year, month - 1, day);
            if (Number.isNaN(dob.getTime())) {
                return null;
            }

            const today = new Date();
            let age = today.getFullYear() - dob.getFullYear();
            const monthDiff = today.getMonth() - dob.getMonth();

            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < dob.getDate())) {
                age -= 1;
            }

            return {
                age,
                formatted: `${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}/${year}`
            };
        }

        function parseDriverLicense(rawData) {
            const data = {
                firstName: '',
                lastName: '',
                middleName: '',
                dob: '',
                licenseNumber: ''
            };

            rawData.split('\n').forEach((line) => {
                if (line.startsWith('DCS')) {
                    data.lastName = line.substring(3).trim();
                } else if (line.startsWith('DAC')) {
                    data.firstName = line.substring(3).trim();
                } else if (line.startsWith('DAD')) {
                    data.middleName = line.substring(3).trim();
                } else if (line.startsWith('DBB')) {
                    data.dob = line.substring(3).trim();
                } else if (line.startsWith('DAQ')) {
                    data.licenseNumber = line.substring(3).trim();
                }
            });

            return data;
        }

        async function loadSale() {
            ui.saleLabel.textContent = `Sale: ${state.saleId}`;
            ui.clerkLabel.textContent = `Clerk: ${state.clerkId}`;
            try {
                const response = await fetch(`${state.apiBase}/sales/${state.saleId}`);
                if (!response.ok) {
                    throw new Error(`Unable to load sale (${response.status})`);
                }

                const payload = await response.json();
                const sale = payload.data;

                ui.totalLabel.textContent = `Total: ${sale.currency || 'USD'} ${sale.total.toFixed(2)}`;
                renderSaleLines(sale);

                if (sale.verification && !sale.verificationExpired) {
                    setVerificationState('Approved', 'Existing verification found. Complete the sale or rescan to refresh.');
                    ui.statusLabel.textContent = 'Status: Verified';
                    ui.completeSaleBtn.disabled = false;
                } else if (sale.verification && sale.verificationExpired) {
                    setVerificationState('Flagged', 'Previous verification expired. Rescan before completing the sale.');
                    ui.statusLabel.textContent = 'Status: Verification expired';
                    ui.completeSaleBtn.disabled = true;
                } else {
                    setVerificationState('Not verified', 'Scan the government ID to proceed with checkout.');
                    ui.statusLabel.textContent = 'Status: Awaiting scan';
                    ui.completeSaleBtn.disabled = true;
                }
            } catch (error) {
                showToast(error.message);
                setVerificationState('Unavailable', 'Sale data could not be loaded. Retry or contact support.');
            }
        }

        async function submitVerification(licenseData, ageData) {
            ui.statusLabel.textContent = 'Status: Sending verification...';
            setVerificationState('Pending', 'Uploading scan result. Hold tight.');
            ui.completeSaleBtn.disabled = true;

            try {
                const response = await fetch(`${state.apiBase}/sales/${state.saleId}/verify`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        clerkId: state.clerkId,
                        scan: {
                            approved: ageData.age >= 21,
                            firstName: licenseData.firstName,
                            lastName: licenseData.lastName,
                            dob: licenseData.dob,
                            age: ageData.age
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error('Unable to record verification. Try again.');
                }

                const payload = await response.json();
                const verification = payload.data;

                if (verification.status === 'approved') {
                    setVerificationState('Approved', 'Verification recorded. You can complete the sale now.');
                    ui.statusLabel.textContent = 'Status: Verified';
                    ui.completeSaleBtn.disabled = false;
                } else {
                    setVerificationState('Flagged', verification.reason || 'Verification rejected.');
                    ui.statusLabel.textContent = 'Status: Verification failed';
                    ui.completeSaleBtn.disabled = true;
                }
            } catch (error) {
                showToast(error.message);
                setVerificationState('Not verified', 'Scan failed to upload. Rescan or refresh.');
                ui.statusLabel.textContent = 'Status: Awaiting scan';
            }
        }

        async function completeSale() {
            const latestVerificationResponse = await fetch(`${state.apiBase}/sales/${state.saleId}`);
            const latestSaleData = await latestVerificationResponse.json();
            const latestVerification = latestSaleData.data.verification;

            if (!latestVerification) {
                showToast('No verification on record. Scan the ID first.');
                return;
            }

            ui.completeSaleBtn.disabled = true;
            ui.completeSaleBtn.textContent = 'Completing...';
            try {
                const response = await fetch(`${state.apiBase}/sales/${state.saleId}/complete`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        verificationId: latestVerification.verificationId
                    })
                });

                if (!response.ok) {
                    const payload = await response.json().catch(() => ({}));
                    throw new Error(payload.message || 'Unable to complete sale. Try again.');
                }

                ui.statusLabel.textContent = 'Status: Completed';
                setVerificationState('Approved', 'Sale flagged as complete. Return to Lightspeed to finish checkout.');
                showToast('Sale completed in mock backend.', 'info');
            } catch (error) {
                showToast(error.message);
                ui.completeSaleBtn.disabled = false;
            } finally {
                ui.completeSaleBtn.textContent = 'Complete Sale';
            }
        }

        function resetResultOverlay() {
            ui.resultOverlay.classList.remove('show');
            ui.ageStatusDiv.textContent = 'Scanning...';
            ui.ageStatusDiv.className = 'age-status';
            ui.nameDiv.textContent = '--';
            ui.dobDiv.textContent = '--';
            ui.ageDiv.textContent = '--';
        }

        function buildVideoConstraints(deviceId) {
            const base = {
                audio: false,
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 },
                    facingMode: deviceId ? undefined : { ideal: 'environment' },
                    advanced: [
                        { focusMode: 'continuous' },
                        { focusMode: 'auto' },
                        { zoom: 2 }
                    ]
                }
            };

            if (deviceId) {
                base.video.deviceId = { exact: deviceId };
            }

            return base;
        }

        function applyTrackEnhancements(track) {
            if (!track || typeof track.getCapabilities !== 'function') {
                return;
            }

            const caps = track.getCapabilities();
            const settings = {};

            if (caps.focusMode && Array.isArray(caps.focusMode)) {
                if (caps.focusMode.includes('continuous')) {
                    settings.focusMode = 'continuous';
                } else if (caps.focusMode.includes('single-shot')) {
                    settings.focusMode = 'single-shot';
                } else if (caps.focusMode.includes('auto')) {
                    settings.focusMode = 'auto';
                }
            }

            if (caps.zoom) {
                const targetZoom =
                    caps.zoom.max > caps.zoom.min
                        ? Math.min(caps.zoom.max, Math.max(caps.zoom.min, caps.zoom.min + (caps.zoom.max - caps.zoom.min) * 0.6))
                        : caps.zoom.min;
                settings.zoom = targetZoom;
            }

            if (caps.torch) {
                settings.torch = false;
            }

            if (Object.keys(settings).length > 0) {
                track.applyConstraints({ advanced: [settings] }).catch(() => undefined);
            }
        }

        async function refreshCameraList() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                logEvent('error', 'Media devices API not available', {});
                showFallbackButtons(true);
                return;
            }

            const loadDevices = async () => {
                const devices = await navigator.mediaDevices.enumerateDevices();
                return devices.filter((device) => device.kind === 'videoinput');
            };

            try {
                logEvent('info', 'Enumerating cameras');
                state.availableDevices = await loadDevices();

                if (state.availableDevices.length === 0) {
                    try {
                        logEvent('warn', 'No cameras enumerated. Attempting prompt.');
                        const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        tempStream.getTracks().forEach((track) => track.stop());
                        state.availableDevices = await loadDevices();
                    } catch (permErr) {
                        logEvent('error', 'Camera permission denied', { name: permErr.name, message: permErr.message });
                        showToast('Enable camera access in Safari settings, then tap Refresh cameras.', 'warn');
                        showFallbackButtons(true);
                    }
                }

                if (!ui.cameraSelect) return;

                ui.cameraSelect.innerHTML = '';

                if (state.availableDevices.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No camera found';
                    ui.cameraSelect.appendChild(option);
                    showFallbackButtons(true);
                    return;
                }

                state.availableDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${index + 1}`;
                    ui.cameraSelect.appendChild(option);
                });
                showFallbackButtons(false);

                if (state.activeDeviceId) {
                    const match = state.availableDevices.find((device) => device.deviceId === state.activeDeviceId);
                    if (match) {
                        ui.cameraSelect.value = state.activeDeviceId;
                    } else {
                        state.activeDeviceId = state.availableDevices[0].deviceId;
                        ui.cameraSelect.value = state.activeDeviceId;
                    }
                } else {
                    state.activeDeviceId = state.availableDevices[0].deviceId;
                    ui.cameraSelect.value = state.activeDeviceId;
                }

                logEvent('info', 'Camera list loaded', { count: state.availableDevices.length });
            } catch (error) {
                logEvent('error', 'Unable to refresh camera list', { name: error.name, message: error.message });
                showToast('Unable to list cameras. Check permissions and refresh.', 'error');
                showFallbackButtons(true);
            }
        }

        function setupZoomForTrack(track) {
            state.activeVideoTrack = track;
            state.zoomCapability = null;
            state.currentZoomValue = 1;

            if (!track || typeof track.getCapabilities !== 'function') {
                logEvent('debug', 'Track capabilities unavailable');
                return;
            }

            const caps = track.getCapabilities();
            if (caps.zoom && typeof caps.zoom.min === 'number' && typeof caps.zoom.max === 'number' && caps.zoom.max > caps.zoom.min) {
                state.zoomCapability = caps.zoom;
                const settings = track.getSettings();
                state.currentZoomValue = typeof settings.zoom === 'number' ? settings.zoom : caps.zoom.min;
                logEvent('info', 'Zoom enabled', { min: caps.zoom.min, max: caps.zoom.max, current: state.currentZoomValue });
            } else {
                logEvent('debug', 'Zoom capability not reported');
            }
        }

        async function applyZoom(target) {
            if (!state.activeVideoTrack || !state.zoomCapability) return;

            const clamped = Math.min(Math.max(target, state.zoomCapability.min), state.zoomCapability.max);
            try {
                await state.activeVideoTrack.applyConstraints({ advanced: [{ zoom: clamped }] });
                state.currentZoomValue = clamped;
            } catch (error) {
                logEvent('warn', 'Failed to apply zoom', { name: error.name, message: error.message });
            }
        }

        function getDistance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function registerGestureHandlers() {
            if (!ui.video) return;

            const handlePointerDown = (evt) => {
                ui.video.setPointerCapture(evt.pointerId);
                state.activePointers.set(evt.pointerId, { x: evt.clientX, y: evt.clientY });
                if (state.activePointers.size === 2 && state.zoomCapability) {
                    const pts = Array.from(state.activePointers.values());
                    state.pinchState = {
                        startDistance: getDistance(pts[0], pts[1]),
                        startZoom: state.currentZoomValue
                    };
                }
            };

            const handlePointerMove = async (evt) => {
                if (!state.activePointers.has(evt.pointerId)) return;
                state.activePointers.set(evt.pointerId, { x: evt.clientX, y: evt.clientY });
                if (state.activePointers.size === 2 && state.pinchState && state.zoomCapability) {
                    const pts = Array.from(state.activePointers.values());
                    const currentDistance = getDistance(pts[0], pts[1]);
                    if (state.pinchState.startDistance > 0) {
                        const scale = currentDistance / state.pinchState.startDistance;
                        const target = state.pinchState.startZoom * scale;
                        await applyZoom(target);
                    }
                }
            };

            const handlePointerUp = (evt) => {
                if (state.activePointers.has(evt.pointerId)) {
                    state.activePointers.delete(evt.pointerId);
                }
                if (state.activePointers.size < 2) {
                    state.pinchState = null;
                }
            };

            ui.video.addEventListener('pointerdown', handlePointerDown);
            ui.video.addEventListener('pointermove', handlePointerMove);
            ui.video.addEventListener('pointerup', handlePointerUp);
            ui.video.addEventListener('pointercancel', handlePointerUp);
            ui.video.addEventListener('pointerout', handlePointerUp);
            ui.video.addEventListener('pointerleave', handlePointerUp);
        }

        async function startScanning(deviceId) {
            resetResultOverlay();

            if (!state.availableDevices.length) {
                await refreshCameraList();
                if (!state.availableDevices.length) {
                    setVerificationState('Unavailable', 'No camera detected. Allow access and tap Refresh cameras.');
                    return;
                }
            }

            await stopScanning();

            try {
                const constraints = buildVideoConstraints(deviceId || state.activeDeviceId);
                state.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                ui.video.srcObject = state.currentStream;
                await ui.video.play();

                const track = state.currentStream.getVideoTracks()[0];
                if (track) {
                    state.activeDeviceId = track.getSettings().deviceId || deviceId || state.activeDeviceId;
                    applyTrackEnhancements(track);
                    setupZoomForTrack(track);
                }

                await refreshCameraList();
                if (state.activeDeviceId && ui.cameraSelect.options.length > 0) {
                    ui.cameraSelect.value = state.activeDeviceId;
                }

                state.isScanning = true;
                setVerificationState('Not verified', 'Hold the ID inside the frame. Pinch with two fingers to zoom and tap the shutter if needed.');
                ui.statusLabel.textContent = 'Status: Scanning...';
                showFallbackButtons(false);

                logEvent('info', 'Camera stream started', { deviceId: state.activeDeviceId });

                codeReader.decodeFromVideoElementContinuously(ui.video, async (result, err) => {
                    if (result && !state.isProcessing) {
                        state.isProcessing = true;
                        try {
                            await handleScan(result.getText());
                        } finally {
                            state.isProcessing = false;
                        }
                    } else if (err && !(err instanceof ZXing.NotFoundException)) {
                        logEvent('warn', 'Decode error (live feed)', { name: err.name, message: err.message });
                    }
                });
            } catch (error) {
                logEvent('error', 'Unable to start scanner', { name: error.name, message: error.message });
                showToast('Unable to access camera. Using native fallback.', 'warn');
                showFallbackButtons(true);
            }
        }

        async function stopScanning({ preserveStream = false } = {}) {
            codeReader.reset();
            state.isScanning = false;
            state.activePointers.clear();
            state.pinchState = null;
            ui.flashOverlay.classList.remove('show');

            if (!preserveStream && state.currentStream) {
                state.currentStream.getTracks().forEach((track) => track.stop());
                state.currentStream = null;
                state.activeVideoTrack = null;
            }
        }

        async function captureOverlayImage() {
            const videoWidth = ui.video.videoWidth;
            const videoHeight = ui.video.videoHeight;
            if (!videoWidth || !videoHeight) {
                throw new Error('Video stream not ready.');
            }

            const videoRect = ui.video.getBoundingClientRect();
            const overlayRect = ui.overlayBox.getBoundingClientRect();

            const scaleX = videoWidth / videoRect.width;
            const scaleY = videoHeight / videoRect.height;

            const cropXBase = Math.max(0, (overlayRect.left - videoRect.left) * scaleX);
            const cropYBase = Math.max(0, (overlayRect.top - videoRect.top) * scaleY);
            const cropWidthBase = Math.min(videoWidth - cropXBase, overlayRect.width * scaleX);
            const cropHeightBase = Math.min(videoHeight - cropYBase, overlayRect.height * scaleY);

            const expandX = Math.min(cropXBase, cropWidthBase * 0.08);
            const expandY = Math.min(cropYBase, cropHeightBase * 0.15);

            const cropX = Math.max(0, cropXBase - expandX);
            const cropY = Math.max(0, cropYBase - expandY);
            const cropWidth = Math.min(videoWidth - cropX, cropWidthBase + expandX * 2);
            const cropHeight = Math.min(videoHeight - cropY, cropHeightBase + expandY * 2);

            const canvas = document.createElement('canvas');
            canvas.width = Math.max(2, Math.floor(cropWidth));
            canvas.height = Math.max(2, Math.floor(cropHeight));
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.filter = 'grayscale(100%) contrast(140%)';
            ctx.drawImage(
                ui.video,
                cropX,
                cropY,
                cropWidth,
                cropHeight,
                0,
                0,
                canvas.width,
                canvas.height
            );

            return canvas.toDataURL('image/png');
        }

        function triggerFlashAnimation() {
            ui.flashOverlay.classList.add('show');
            setTimeout(() => ui.flashOverlay.classList.remove('show'), 140);
        }

        async function capturePhoto({ showFlash = false } = {}) {
            if (showFlash) triggerFlashAnimation();
            const dataUrl = await captureOverlayImage();
            logEvent('info', 'Manual frame captured from live feed');
            return dataUrl;
        }

        function showPreview(dataUrl) {
            state.lastCaptureDataUrl = dataUrl;
            ui.previewImage.src = dataUrl;
            ui.previewStatus.textContent = '';
            ui.previewConfirmBtn.disabled = false;
            ui.previewRetakeBtn.disabled = false;
            ui.capturePreview.classList.add('show');
            ui.capturePreview.setAttribute('aria-hidden', 'false');
        }

        function hidePreview() {
            state.lastCaptureDataUrl = null;
            ui.capturePreview.classList.remove('show');
            ui.capturePreview.setAttribute('aria-hidden', 'true');
            ui.previewImage.src = '';
            ui.previewStatus.textContent = '';
        }

        async function manualSnapshot({ showFlash = false } = {}) {
            if (state.isProcessing) return;

            if (!state.currentStream) {
                await startScanning(state.activeDeviceId);
                showToast('Camera restarted. Try again once the preview appears.', 'info');
                return;
            }

            if (ui.video.readyState < 2 || !ui.video.videoWidth) {
                showToast('Camera is still focusing. Hold steady and retry.', 'info');
                return;
            }

            codeReader.reset();
            state.isScanning = false;

            try {
                state.isProcessing = true;
                const dataUrl = await capturePhoto({ showFlash });
                showPreview(dataUrl);
            } catch (error) {
                logEvent('error', 'Manual capture failed', { name: error.name, message: error.message });
                showToast('Unable to capture image. Adjust and try again.', 'error');
                ui.flashOverlay.classList.remove('show');
                await startScanning(state.activeDeviceId);
            } finally {
                state.isProcessing = false;
            }
        }

        async function decodeDataUrl(dataUrl) {
            const image = new Image();
            image.src = dataUrl;
            await image.decode();
            const result = await codeReader.decodeFromImageElement(image);
            logEvent('info', 'Decoded barcode from still frame');
            return result.getText();
        }

        async function handleScan(rawData) {
            hidePreview();
            try {
                await stopScanning();

                const licenseData = parseDriverLicense(rawData);

                if (!licenseData.firstName && !licenseData.lastName) {
                    throw new Error('Could not read name from ID. Please rescan.');
                }

                if (!licenseData.dob) {
                    throw new Error('Could not read date of birth. Please rescan.');
                }

                const ageData = calculateAge(licenseData.dob);
                if (!ageData) {
                    throw new Error('Unable to calculate age. Try another scan.');
                }

                const fullName = [licenseData.firstName, licenseData.middleName, licenseData.lastName]
                    .filter(Boolean)
                    .join(' ');

                ui.nameDiv.textContent = fullName || '--';
                ui.dobDiv.textContent = ageData.formatted;
                ui.ageDiv.textContent = `${ageData.age}`;

                if (ageData.age >= 21) {
                    ui.ageStatusDiv.textContent = '21+ Verified';
                    ui.ageStatusDiv.className = 'age-status approved';
                } else {
                    ui.ageStatusDiv.textContent = 'Under 21';
                    ui.ageStatusDiv.className = 'age-status denied';
                }

                ui.resultOverlay.classList.add('show');
                logEvent('info', 'Scan decoded', { age: ageData.age, name: fullName });

                await submitVerification(licenseData, ageData);
            } catch (error) {
                logEvent('error', 'Scan failed', { message: error.message });
                showToast(error.message || 'Scan failed. Adjust the ID and try again.', 'error');
                await startScanning(state.activeDeviceId);
            }
        }

        ui.captureFrameBtn.addEventListener('click', () => manualSnapshot({ showFlash: true }));
        ui.shutterButton.addEventListener('click', () => manualSnapshot({ showFlash: true }));
        ui.fallbackCaptureBtn.addEventListener('click', () => ui.fallbackInput.click());

        ui.fallbackInput.addEventListener('change', (event) => {
            if (state.isProcessing) return;

            const file = event.target.files && event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                const dataUrl = reader.result;
                showPreview(dataUrl);
                logEvent('info', 'Photo imported from native camera');
            };
            reader.onerror = () => {
                logEvent('error', 'Unable to load native photo', { name: reader.error && reader.error.name });
                showToast('Unable to load photo. Try again.', 'error');
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        });

        registerGestureHandlers();

        ui.previewRetakeBtn.addEventListener('click', async () => {
            if (state.isProcessing) return;
            logEvent('info', 'Retake requested');
            hidePreview();
            await startScanning(state.activeDeviceId);
        });

        ui.previewConfirmBtn.addEventListener('click', async () => {
            if (!state.lastCaptureDataUrl || state.isProcessing) return;
            state.isProcessing = true;
            ui.previewConfirmBtn.disabled = true;
            ui.previewRetakeBtn.disabled = true;
            ui.previewStatus.textContent = 'Processing...';
            logEvent('info', 'Decoding confirmed still photo');
            try {
                const rawData = await decodeDataUrl(state.lastCaptureDataUrl);
                hidePreview();
                await handleScan(rawData);
            } catch (error) {
                logEvent('error', 'Preview decode failed', { name: error.name, message: error.message });
                ui.previewStatus.textContent = 'Could not read. Adjust and retake.';
                ui.previewConfirmBtn.disabled = false;
                ui.previewRetakeBtn.disabled = false;
                showToast('Could not read barcode. Retake the photo.', 'error');
            } finally {
                state.isProcessing = false;
            }
        });

        ui.scanAgainBtn.addEventListener('click', async () => {
            logEvent('info', 'Scan again requested');
            resetResultOverlay();
            await startScanning(state.activeDeviceId);
        });

        ui.restartScanBtn.addEventListener('click', async () => {
            logEvent('info', 'Restart scan requested');
            resetResultOverlay();
            await startScanning(state.activeDeviceId);
        });

        ui.completeSaleBtn.addEventListener('click', completeSale);

        ui.refreshCamerasBtn.addEventListener('click', async () => {
            await refreshCameraList();
            await startScanning(ui.cameraSelect.value);
        });

        ui.cameraSelect.addEventListener('change', async (event) => {
            state.activeDeviceId = event.target.value;
            await startScanning(state.activeDeviceId);
        });

        window.addEventListener('beforeunload', () => stopScanning());

        async function init() {
            logEvent('info', 'Scanner initialising', { saleId: state.saleId, clerkId: state.clerkId });
            await loadSale();
            await refreshCameraList();
            await startScanning(state.activeDeviceId);
        }

        init();
    })();
    </script>
</body>
</html>
