<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THC Club - Smart Checkout</title>

    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        // Apply verify-only class as early as possible to avoid flashing tender UI.
        (function () {
            try {
                var p = new URLSearchParams(window.location.search || '');
                var mode = String(p.get('mode') || '').trim().toLowerCase();
                var verify = mode === 'verify' || mode === 'verify-only' || mode === 'verifyonly';
                if (!verify) {
                    var v = String(p.get('verifyOnly') || p.get('verify') || '').trim().toLowerCase();
                    verify = v === '1' || v === 'true' || v === 'yes' || v === 'on';
                }
                // In the Lightspeed gateway iframe, params are sometimes dropped; treat embedded as verify-only.
                try {
                    if (window.self !== window.top) verify = true;
                } catch (e) {
                    verify = true;
                }
                if (verify) document.documentElement.classList.add('verify-only');
            } catch (e) { }
        })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --thc-orange: #e55c2c;
            --thc-blue: #42b4e6;
            --thc-black: #1a1a1a;
            --thc-green: #2ea750;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --bg-dark: #0f1419;
            --card-bg: rgba(26, 26, 46, 0.95);
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            min-height: 100vh;
            color: white;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
        }

        /* Embedded/iframe mode: render as a compact popup over the POS. */
        html.embedded,
        html.embedded body {
            /* Fill the entire iframe with the dark overlay so the POS white doesn't show through. */
            background: rgba(15, 20, 25, 0.98);
        }

        html.embedded body {
            padding: calc(env(safe-area-inset-top, 0px) + 16px) calc(env(safe-area-inset-right, 0px) + 16px) calc(env(safe-area-inset-bottom, 0px) + 16px) calc(env(safe-area-inset-left, 0px) + 16px);
            min-height: 100vh;
            overflow: hidden;
            justify-content: center;
        }

        html.embedded .grid-bg {
            display: none;
        }

        html.embedded .scanner-wrap {
            margin: 0 auto;
            width: min(92vw, 860px);
            max-width: 860px;
            max-height: calc(100vh - 32px - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            background: rgba(15, 20, 25, 0.92);
            border-radius: 18px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 30px 26px;
        }

        html.embedded .logo {
            width: 170px;
        }

        html.embedded .main-title {
            font-size: clamp(34px, 4vw, 46px);
            letter-spacing: 2px;
        }

        html.embedded .subtitle {
            font-size: clamp(16px, 2.2vw, 20px);
        }

        html.embedded #btnScanNow {
            font-size: clamp(18px, 2.4vw, 22px);
            padding: 20px 18px;
        }

        /* verify-only styling is controlled by JS so we can optionally show tender choices after scan. */

        /* Animated grid background */
        .grid-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(66, 180, 230, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(66, 180, 230, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }

        .scanner-wrap {
            position: relative;
            width: 100%;
            max-width: 480px;
            padding: 20px;
            text-align: center;
        }

        /* ========== LOGO & RING ========== */
        .logo-container {
            position: relative;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .logo {
            width: 140px;
            height: auto;
            filter: drop-shadow(0 0 30px rgba(66, 180, 230, 0.3));
            z-index: 2;
        }

        .scan-ring {
            position: absolute;
            width: 180px;
            height: 180px;
            border: 3px solid transparent;
            border-top-color: var(--thc-orange);
            border-right-color: var(--thc-blue);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .scanning .scan-ring {
            opacity: 1;
            animation: spinRing 1.5s linear infinite;
        }

        @keyframes spinRing {
            to {
                transform: rotate(360deg);
            }
        }

        /* ========== HEADERS ========== */
        .main-title {
            font-size: 28px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
        }

        /* ========== TENDER SELECTION BOX ========== */
        .tender-box {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            text-align: left;
        }

        .tender-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .choose-badge {
            background: var(--thc-orange);
            color: black;
            font-weight: 900;
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 5px;
        }

        .tender-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .tender-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-weight: 700;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .tender-btn:active {
            transform: scale(0.95);
        }

        .tender-btn.selected {
            border-color: var(--thc-blue);
            background: rgba(66, 180, 230, 0.1);
            box-shadow: 0 0 20px rgba(66, 180, 230, 0.3);
        }

        .tender-hint {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            margin-top: 15px;
        }

        /* ========== SCAN BUTTON ========== */
        .scan-now-btn {
            background: rgba(229, 92, 44, 0.1);
            border: 2px solid var(--thc-orange);
            color: var(--thc-orange);
            width: 100%;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 0 auto;
            opacity: 0.5;
            pointer-events: none;
        }

        .scan-now-btn.ready {
            opacity: 1;
            pointer-events: auto;
            background: rgba(229, 92, 44, 0.2);
            box-shadow: 0 0 30px rgba(229, 92, 44, 0.2);
        }

        .scan-now-btn:active {
            transform: scale(0.97);
        }

        .scan-dot {
            width: 8px;
            height: 8px;
            background: currentColor;
            border-radius: 50%;
        }

        .scanning .scan-dot {
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.4;
                transform: scale(0.8);
            }
        }

        /* ========== SCAN CAPTURE INPUT (INVISIBLE) ========== */
        .scan-now-wrap {
            position: relative;
            width: 100%;
        }

        /* The visual CTA is the button; the actual interactive element is the input overlay.
           In verify-only mode we style the input itself like the CTA so iPad/WKWebView routes Bluetooth HID keystrokes
           as real typing into a focused field (the most reliable path). */
        .scan-now-wrap #btnScanNow {
            position: relative;
            z-index: 1;
            pointer-events: none;
        }

        .scan-now-wrap #ghostInput {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            background: transparent;
            border: 0;
            margin: 0;
            padding: 0;

            /* Default: invisible characters (we show masked UI separately when needed). */
            color: transparent;
            -webkit-text-fill-color: transparent;
            caret-color: var(--thc-orange);
            text-shadow: 0 0 0 transparent;
            text-align: center;

            outline: none;
            box-shadow: none;

            /* Enabled only when ready (prevents arming before tender selection in non-verify modes). */
            pointer-events: none;
        }

        .scan-now-wrap.ready #ghostInput {
            pointer-events: auto;
        }

        .scan-now-wrap #ghostInput:focus {
            outline: none;
        }

        /* Verify-only (iPad) reliability mode: make the input itself look like the CTA. */
        html.verify-only .scan-now-wrap #btnScanNow {
            display: none;
        }

        html.verify-only .scan-now-wrap #ghostInput {
            position: relative;
            inset: auto;
            display: block;
            pointer-events: auto;
            padding: 18px 18px;
            border-radius: 50px;
            border: 2px solid var(--thc-orange);
            background: rgba(229, 92, 44, 0.2);
            box-shadow: 0 0 30px rgba(229, 92, 44, 0.2);
            font-size: 18px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            caret-color: var(--thc-orange);
            -webkit-text-security: disc; /* mask typed chars */
            color: rgba(255, 255, 255, 0.35);
            -webkit-text-fill-color: rgba(255, 255, 255, 0.35);
        }

        html.verify-only .scan-now-wrap #ghostInput::placeholder {
            color: var(--thc-orange);
            -webkit-text-fill-color: var(--thc-orange);
            opacity: 0.9;
        }

        /* Hide raw keystrokes in normal mode (still captured in ghostInput). */
        #scanPreview {
            display: none !important;
        }

        body.show-keys #scanPreview {
            display: flex !important;
        }

        /* Masked capture view: show a tiny "dots/asterisks" indicator without exposing barcode content. */
        body.mask-keys #scanPreview {
            font-size: 10px !important;
            opacity: 0.85;
            border-color: rgba(0, 255, 0, 0.6) !important;
            padding: 8px !important;
            min-height: 34px !important;
        }

        .overlay-card {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 20, 25, 0.95);
            backdrop-filter: blur(10px);
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            text-align: center;
        }

        .overlay-card.active {
            display: flex;
        }

        .overlay-content {
            background: var(--card-bg);
            border: 2px solid var(--thc-green);
            border-radius: 20px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .overlay-card.error .overlay-content {
            border-color: var(--error);
        }

        .overlay-card h2 {
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .overlay-card p {
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .btn-action {
            background: var(--thc-orange);
            border: none;
            color: black;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 800;
            cursor: pointer;
            text-transform: uppercase;
        }

        /* ========== CASH CALCULATOR ========== */
        .cash-wrap {
            display: none;
            width: 100%;
            max-width: 920px;
            padding: 20px 18px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            overflow-x: hidden;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            box-sizing: border-box;
        }

        .cash-layout {
            display: flex;
            gap: 22px;
            align-items: stretch;
        }

        .cash-logo-rail {
            width: 160px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cash-logo {
            width: 132px;
            height: auto;
            filter: drop-shadow(0 0 18px rgba(66, 180, 230, 0.25));
            opacity: 0.85;
        }

        .cash-center {
            flex: 1;
            min-width: 320px;
            text-align: left;
        }

        .cash-right {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .quick-picks {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quick-btn {
            width: 100%;
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.14);
            color: white;
            padding: 18px 16px;
            border-radius: 15px;
            font-size: 22px;
            font-weight: 700;
            cursor: pointer;
            letter-spacing: 0.2px;
            touch-action: manipulation;
        }

        .quick-btn:active {
            transform: scale(0.98);
        }

        .cash-total-banner {
            background: rgba(255, 255, 255, 0.05);
            padding: 22px;
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .cash-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        @media (max-width: 860px) {
            .cash-layout {
                flex-direction: column;
                gap: 16px;
            }

            .cash-logo-rail {
                width: 100%;
            }

            .cash-right {
                width: 100%;
            }

            .cash-center {
                min-width: 0;
            }
        }

        .cash-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 22px;
            border-radius: 14px;
            font-size: 24px;
            font-weight: 700;
            color: white;
            cursor: pointer;
            touch-action: manipulation;
        }

        .cash-btn-spacer {
            visibility: hidden;
            pointer-events: none;
        }

        .cash-btn:active {
            background: var(--thc-orange);
            color: black;
        }

        .change-display {
            font-size: 32px;
            font-weight: 800;
            color: var(--thc-green);
            margin: 20px 0;
        }

        .hidden {
            display: none !important;
        }

        #debugPanel {
            display: none;
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 8px;
            z-index: 10000;
            max-width: 250px;
            border: 1px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            pointer-events: auto;
        }

        body.debug-ui #debugPanel {
            display: block;
        }

        #debugFab {
            display: none;
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 46px;
            height: 46px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(0, 255, 255, 0.35);
            color: #0ff;
            font-family: monospace;
            font-size: 12px;
            font-weight: 800;
            z-index: 10001;
            cursor: pointer;
            opacity: 0.25;
            pointer-events: auto;
        }

        html.embedded #debugFab,
        body.embedded #debugFab {
            display: block;
        }

        body.debug-ui #debugFab {
            opacity: 0.95;
        }

        .debug-btn {
            background: #222;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 6px 10px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 11px;
            border-radius: 4px;
            width: 100%;
            text-transform: uppercase;
            font-weight: bold;
        }

        #debugStatus {
            margin: 8px 0;
            color: #fff;
            padding: 4px;
            background: rgba(255, 255, 255, 0.1);
            word-break: break-all;
        }
    </style>
</head>

<body class="embedded">
    <button id="debugFab" type="button" aria-label="Toggle debug">DBG</button>
    <div id="debugPanel">
        <div style="font-weight: bold; border-bottom: 1px solid #0f0; margin-bottom: 5px;">REMOTE DIAGNOSTICS</div>
        <div>URL: <span id="debugUrl">...</span></div>
        <div>ID: <span id="debugSale">...</span></div>
        <div>SaleSrc: <span id="debugSaleSource">...</span></div>
        <div>Focus: <span id="debugFocus">...</span></div>
        <div>GhostLen: <span id="debugGhostLen">0</span></div>
        <div>BufLen: <span id="debugBufLen">0</span></div>
        <div>State: <span id="debugState">...</span></div>
        <div>Fields: <span id="debugFields">...</span></div>
        <div id="debugStatus">SYSTEM READY</div>
        <button class="debug-btn" onclick="testConnectivity(event)">TEST PING</button>
        <div style="margin-top: 10px; font-size: 10px; color: #9ff; opacity: 0.95;">CLIENT LOGS</div>
        <div id="debugClientLogs"
            style="margin-top: 6px; font-size: 9px; max-height: 70px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; font-family: monospace; border: 1px solid rgba(0,255,255,0.25);">
            (waiting...)
        </div>
        <div id="debugLogs"
            style="margin-top: 10px; font-size: 9px; max-height: 80px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; font-family: monospace; border: 1px solid rgba(0,255,0,0.2);">
            (Waiting for scan...)
        </div>
    </div>
    <div class="grid-bg"></div>

    <div class="scanner-wrap" id="mainWrap">
        <!-- Logo Area -->
        <div class="logo-container" id="visualRoot">
            <div class="scan-ring"></div>
            <img src="/frontend/assets/thc-logo.png" alt="THC Club" class="logo">
        </div>

        <h1 class="main-title" id="mainTitle">Verify Age</h1>
        <p class="subtitle" id="mainSubtitle">Tap to start scanning, then focus on the barcode until it confirms.</p>

        <!-- Scan Trigger -->
        <!-- Scan Data Preview (Visible Keystrokes) -->
        <div id="scanPreview"
            style="margin-bottom: 20px; font-family: monospace; font-size: 14px; color: #0f0; background: rgba(0,0,0,0.3); padding: 10px; border: 1px solid #0f0; border-radius: 8px; word-break: break-all; min-height: 40px; text-align: left; display: flex; align-items: center;">
            <span style="opacity: 0.5; margin-right: 10px;">SCAN:</span>
            <span id="scanPreviewText">...</span>
        </div>

        <div id="scanNowWrap" class="scan-now-wrap">
            <button id="btnScanNow" class="scan-now-btn" type="button" tabindex="-1" aria-hidden="true">Scan Now</button>
            <input id="ghostInput" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
                inputmode="none" aria-label="Scan capture" placeholder="Tap here, then scan ID" />
        </div>

        <!-- Success overlay -->
        <div id="successOverlay" class="overlay-card">
            <div class="overlay-content">
                <h2 style="color: var(--thc-green)">Verified</h2>
                <p id="successMsg">Age: --</p>
                <p id="successName" style="opacity: 0.9; margin-top: -10px; margin-bottom: 18px;">--</p>
                <div id="successDetails" style="display: none;"></div>
                <button class="btn-action" id="btnContinue" style="width: 100%;">Continue</button>
            </div>
        </div>

        <!-- Error overlay -->
        <div id="errorOverlay" class="overlay-card error">
            <div class="overlay-content">
                <h2 style="color: var(--error)">Error</h2>
                <p id="errorMsg">Failed to verify ID</p>
                <div style="display: flex; gap: 10px; flex-direction: column;">
                    <button class="btn-action" style="background: var(--error)" onclick="resetUI()">Try
                        Again</button>
                    <button class="btn-action" style="background: rgba(255,255,255,0.1); color: white;"
                        onclick="closeGateway()">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Close helper overlay (shown only if Lightspeed doesn't close the modal) -->
        <div id="closeOverlay" class="overlay-card">
            <div class="overlay-content">
                <h2>Return to POS</h2>
                <p>If this screen doesn’t close automatically, tap Return.</p>
                <button class="btn-action" type="button" onclick="closeGateway()">Return</button>
            </div>
        </div>
    </div>

    <!-- Cash Calculator -->
    <div class="cash-wrap" id="cashWrap">
        <div class="cash-layout">
            <div class="cash-logo-rail" aria-hidden="true">
                <img src="/frontend/assets/thc-logo.png" alt="THC Club" class="cash-logo">
            </div>

            <div class="cash-center">
                <div class="cash-total-banner">
                    <div style="font-size: 12px; opacity: 0.6;">SALE TOTAL</div>
                    <div id="dispSaleTotal" style="font-size: 48px; font-weight: 800;">$0.00</div>
                </div>

                <div style="font-size: 12px; opacity: 0.6; margin-bottom: 10px;">CASH RECEIVED</div>
                <div id="dispReceived" style="font-size: 40px; font-weight: 700; margin-bottom: 20px;">$0.00</div>

                <div id="changeBox" class="hidden">
                    <div style="font-size: 12px; opacity: 0.6;">GIVE CHANGE</div>
                    <div id="dispChange" class="change-display">$0.00</div>
                    <button class="btn-action" id="btnCompleteSale" style="width: 100%; padding: 20px;"
                        type="button">Complete Cash Sale</button>
                </div>
            </div>

            <div class="cash-right">
                <div class="quick-picks">
                    <button class="quick-btn" id="btnQuickExact" type="button">Exact</button>
                    <button class="quick-btn" id="btnQuickNextDollar" type="button">Next $</button>
                    <button class="quick-btn" id="btnQuickNextFive" type="button">$10</button>
                </div>

                <div class="cash-grid">
                    <button class="cash-btn" onclick="addMoney('7')">7</button>
                    <button class="cash-btn" onclick="addMoney('8')">8</button>
                    <button class="cash-btn" onclick="addMoney('9')">9</button>
                    <button class="cash-btn" onclick="addMoney('4')">4</button>
                    <button class="cash-btn" onclick="addMoney('5')">5</button>
                    <button class="cash-btn" onclick="addMoney('6')">6</button>
                    <button class="cash-btn" onclick="addMoney('1')">1</button>
                    <button class="cash-btn" onclick="addMoney('2')">2</button>
                    <button class="cash-btn" onclick="addMoney('3')">3</button>
                    <button class="cash-btn" onclick="addMoney('.')">.</button>
                    <button class="cash-btn" onclick="addMoney('0')">0</button>
                    <button class="cash-btn cash-btn-spacer" type="button" tabindex="-1" aria-hidden="true"></button>
                    <button class="cash-btn" type="button" onclick="backspaceMoney()">X</button>
                    <button class="cash-btn" type="button" onclick="clearMoney()" style="color: var(--error); grid-column: span 2;">C</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data from URL (Added fallbacks for different Lightspeed triggers)
        const urlParams = new URLSearchParams(window.location.search);
        const debugKeysEnabled = ['1', 'true', 'yes', 'on'].includes((urlParams.get('debugKeys') || urlParams.get('debug') || '').toLowerCase());
        if (debugKeysEnabled) {
            document.body.classList.add('show-keys');
        }
        const maskKeysEnabled = ['1', 'true', 'yes', 'on'].includes((urlParams.get('maskKeys') || urlParams.get('maskKeysUi') || urlParams.get('mask') || '').toLowerCase());
        if (maskKeysEnabled) {
            // Show the capture UI, but mask the characters so staff never see raw barcode data.
            document.body.classList.add('show-keys');
            document.body.classList.add('mask-keys');
        }
        const debugUiEnabled = ['1', 'true', 'yes', 'on'].includes((urlParams.get('debugUi') || urlParams.get('debug') || '').toLowerCase());
        if (debugUiEnabled) {
            document.body.classList.add('debug-ui');
        }
        let remoteTelemetryEnabled =
            debugUiEnabled ||
            debugKeysEnabled ||
            ['1', 'true', 'yes', 'on'].includes(String(urlParams.get('telemetry') || urlParams.get('remoteTelemetry') || urlParams.get('clientLog') || '').trim().toLowerCase());

        const embeddedMode =
            window.self !== window.top ||
            ['1', 'true', 'yes', 'on'].includes(String(urlParams.get('embedded') || urlParams.get('embed') || '').toLowerCase());
        if (embeddedMode) {
            document.documentElement.classList.add('embedded');
            document.body.classList.add('embedded');
        }

        // Stable gateway is used as a scan-only verifier: after success, return to POS and use native tender buttons.
        // Default this page to verify-only (no tender chooser). You can opt into tender/cash UI with `?mode=tender`.
        const verifyOnlyMode = (() => {
            const raw = String(urlParams.get('mode') || '').trim().toLowerCase();
            if (raw === 'tender' || raw === 'cash' || raw === 'gateway' || raw === 'pay') return false;
            if (raw === 'verify' || raw === 'verify-only' || raw === 'verifyonly') return true;

            const explicitRaw = String(urlParams.get('verifyOnly') || urlParams.get('verify') || urlParams.get('scanOnly') || '').trim().toLowerCase();
            if (['0', 'false', 'no', 'off'].includes(explicitRaw)) return false;
            if (['1', 'true', 'yes', 'on'].includes(explicitRaw)) return true;

            if (embeddedMode) return true;
            return true;
        })();

        const postScanTenderChoice = (() => {
            const raw = String(urlParams.get('postScan') || urlParams.get('afterScan') || '').trim().toLowerCase();
            if (raw === 'tender' || raw === 'cashcard') return true;
            return ['1', 'true', 'yes', 'on'].includes(String(urlParams.get('postScanTender') || '').trim().toLowerCase());
        })();

        // Lightspeed Retail X-Series Payments API (gateway-in-iframe) uses postMessage JSON strings.
        // Key steps: SETUP (toggle close button), ACCEPT (complete sale), DECLINE (back to pay screen), EXIT (close dialogs/unbind).
        // Docs: https://x-series-api.lightspeedhq.com/docs/payments_api_reference
        const lightspeedOriginParam =
            (urlParams.get('origin') || urlParams.get('ls_origin') || urlParams.get('parent_origin') || '').trim();

        function normalizeLightspeedOrigin(origin) {
            const value = String(origin || '').trim();
            if (!value) return null;
            if (value.startsWith('http://') || value.startsWith('https://')) return value;
            return `https://${value}`;
        }

        const lightspeedTargetOrigin = normalizeLightspeedOrigin(lightspeedOriginParam);
        let resolvedLightspeedOrigin = null;
        const lsCloseMode = String(urlParams.get('lsCloseMode') || 'exit').trim().toLowerCase();
        // Default is verification-only: close/return to POS without marking a payment as accepted.
        // If you intentionally want Lightspeed to record a payment for this gateway payment type, set `lsCashMode=accept`.
        const lsCashMode = String(urlParams.get('lsCashMode') || 'exit').trim().toLowerCase();
        const apiKeyParam = String(urlParams.get('apiKey') || '').trim();

        function getApiHeaders(extra = {}) {
            const headers = { ...extra };
            if (apiKeyParam) headers['X-API-Key'] = apiKeyParam;
            return headers;
        }

        function postToLightspeed(payload) {
            // Prefer an explicit Lightspeed origin via query params, but in embedded/iframe mode
            // still attempt postMessage using '*' so we can request DATA reliably on iPad webviews.
            if (!embeddedMode && !lightspeedTargetOrigin) return false;
            try {
                const message = JSON.stringify(payload);
                const target = resolvedLightspeedOrigin || lightspeedTargetOrigin || '*';
                const candidates = [];
                if (window.opener && window.opener !== window) candidates.push(window.opener);
                candidates.push(window.parent);
                if (window.top && window.top !== window.parent) candidates.push(window.top);

                for (const receiver of candidates) {
                    try {
                        receiver.postMessage(message, target);
                    } catch (e) {
                        // ignore and keep trying other candidates
                    }
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        function lsSetup(enableClose) {
            return postToLightspeed({
                step: 'SETUP',
                setup: { enable_close: Boolean(enableClose) }
            });
        }

        function lsExit() {
            return postToLightspeed({ step: 'EXIT' });
        }

        function lsData() {
            return postToLightspeed({ step: 'DATA' });
        }

        function lsDecline({ receiptHtmlExtra = null, print = false } = {}) {
            const payload = { step: 'DECLINE', print: Boolean(print) };
            if (typeof receiptHtmlExtra === 'string') payload.receipt_html_extra = receiptHtmlExtra;
            return postToLightspeed(payload);
        }

        function lsAccept({ receiptHtmlExtra = null, print = false, amount = null } = {}) {
            const payload = { step: 'ACCEPT', print: Boolean(print) };
            if (typeof receiptHtmlExtra === 'string') payload.receipt_html_extra = receiptHtmlExtra;
            if (Number.isFinite(Number(amount))) {
                const normalized = Math.round(Number(amount) * 100) / 100;
                payload.amount = normalized;
                payload.approved_amount = normalized;
            }
            return postToLightspeed(payload);
        }

        function tryCloseWindow() {
            try {
                window.close();
                return true;
            } catch (e) {
                return false;
            }
        }
        // NOTE: Lightspeed gateway iframes sometimes pass `reference_id` (payment ref) rather than the actual sale id.
        // Always prefer the POS sale id from postMessage DATA when available.
        let saleId = null;
        let saleIdSource = null;
        const saleIdCandidates = [
            ['sale_id', urlParams.get('sale_id')],
            ['saleId', urlParams.get('saleId')],
            ['transaction_id', urlParams.get('transaction_id')],
            ['reference', urlParams.get('reference')],
            ['reference_id', urlParams.get('reference_id')]
        ];
        for (const [key, value] of saleIdCandidates) {
            const v = String(value || '').trim();
            if (!v) continue;
            saleId = v;
            saleIdSource = `query:${key}`;
            break;
        }
        let paymentReferenceId = saleIdSource === 'query:reference' || saleIdSource === 'query:reference_id' ? saleId : null;

        const clerkIdParam =
            (urlParams.get('clerk_id') || urlParams.get('clerkId') || urlParams.get('user_id') || urlParams.get('userId') || '').trim();
        const registerIdParam =
            (urlParams.get('register_id') || urlParams.get('registerId') || '').trim();

        const rawAmount = urlParams.get('amount') || urlParams.get('total') || urlParams.get('sale_total') || '0';
        const saleAmount = parseFloat(rawAmount) > 100 ? parseFloat(rawAmount) / 100 : parseFloat(rawAmount);

        // Dual-mode behavior (single URL):
        // - Default: attempt to auto-arm scanning on load.
        // - Fallback: if iOS blocks focus/key routing, staff can tap the Scan button to re-arm.
        // You can force manual-only testing with `?tapToScan=1`.
        const manualOnlyTapToScan = (() => {
            const raw = String(urlParams.get('tapToScan') || urlParams.get('requireTap') || '').trim().toLowerCase();
            if (['1', 'true', 'yes', 'on'].includes(raw)) return true;
            if (['0', 'false', 'no', 'off'].includes(raw)) return false;
            return false;
        })();

        const isIOSLike = (() => {
            try {
                const ua = String(navigator.userAgent || '');
                const platform = String(navigator.platform || '');
                const iOSDevice = /iPad|iPhone|iPod/i.test(ua);
                const iPadOS = platform === 'MacIntel' && Number(navigator.maxTouchPoints || 0) > 1;
                return iOSDevice || iPadOS;
            } catch (e) {
                return false;
            }
        })();

        const autoStartScan = (() => {
            const raw = String(urlParams.get('autoStart') || '').trim().toLowerCase();
            if (['0', 'false', 'no', 'off'].includes(raw)) return false;
            if (['1', 'true', 'yes', 'on'].includes(raw)) return true;
            // iPad/WKWebView in an iframe often refuses to route Bluetooth HID keystrokes until a user taps inside
            // the iframe. Auto-start looks like it "hangs" (until someone taps debug/test ping).
            // Default to manual arm on iOS-like devices for reliability; allow auto via `?autoStart=1` for testing.
            if (verifyOnlyMode && embeddedMode && !manualOnlyTapToScan) {
                return !isIOSLike;
            }
            return false;
        })();

        // In verify-only mode inside the Lightspeed iPad iframe, the most reliable pattern is:
        // - user taps inside the iframe (our CTA overlay input)
        // - keep the input readonly so the on-screen keyboard does not appear
        // - capture the HID scan via keydown buffering (not input.value)
        const noKeyboardHackEnabled = (() => {
            const raw = String(urlParams.get('noKbHack') || urlParams.get('noKeyboardHack') || urlParams.get('readonlyFocusHack') || '').trim().toLowerCase();
            return ['1', 'true', 'yes', 'on'].includes(raw);
        })();

        // Only enable readonly capture when explicitly requested; it can improve iPad UX by suppressing
        // the on-screen keyboard, but some environments are more reliable with a normal editable input.
        const preferReadOnlyCapture = noKeyboardHackEnabled;

        // State
        let selectedTender = null;
        let isScanning = false;
        let isProcessingScan = false;
        let latestVerificationId = null;
        let barcodeBuffer = '';
        let scanIdleTimer = null;
        let scanHardTimer = null;
        let scanLocked = false;
        let receivedAmountStr = "";
        let pendingVerifyPayload = null;
        let pageOpenedAtMs = Date.now();
        let scanArmedAtMs = null;
        let lastUserGestureAtMs = null;
        const clientSessionId = (() => {
            try {
                if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
                    return crypto.randomUUID();
                }
            } catch (e) { }
            return `pg-${Date.now()}-${Math.floor(Math.random() * 1e6)}`;
        })();
        let remoteProgressNextLen = 50;

        function clientLog(message, extra = null) {
            try {
                const el = document.getElementById('debugClientLogs');
                if (!el) return;
                const time = new Date().toISOString().slice(11, 19);
                const line = document.createElement('div');
                line.style.marginBottom = '2px';
                const suffix = extra ? ` ${JSON.stringify(extra)}` : '';
                line.textContent = `[${time}] ${message}${suffix}`;
                if (el.textContent && el.textContent.trim() === '(waiting...)') el.textContent = '';
                el.appendChild(line);
                el.scrollTop = el.scrollHeight;
            } catch (e) { }
        }

        // Backend warmup: on iPad/Lightspeed WKWebView, a "warm" serverless + DB makes the flow feel instant.
        // IMPORTANT: do not gate keystroke capture on this; we warm in parallel and only surface failures.
        let backendWarmPromise = null;
        let backendWarmAtMs = 0;
        let backendWarmOk = null;

        async function warmupBackend(reason = 'warmup') {
            try {
                const now = Date.now();
                const recentEnough = backendWarmAtMs && (now - backendWarmAtMs) < 30000;
                if (recentEnough && backendWarmOk === true) return { ok: true, cached: true };
                if (backendWarmPromise) return backendWarmPromise;

                backendWarmPromise = (async () => {
                    const startedAt = Date.now();
                    try {
                        const res = await fetch(`/api/health?db=1&t=${Date.now()}`, { headers: getApiHeaders() });
                        const json = await res.json().catch(() => ({}));
                        backendWarmOk = res.ok && String(json.status || '').toLowerCase() === 'ok';
                        backendWarmAtMs = Date.now();
                        clientLog('warmupBackend', { reason, ok: backendWarmOk, ms: Date.now() - startedAt });
                        return { ok: backendWarmOk, json };
                    } catch (err) {
                        backendWarmOk = false;
                        backendWarmAtMs = Date.now();
                        clientLog('warmupBackend failed', { reason, message: err?.message || String(err) });
                        return { ok: false, error: err?.message || String(err) };
                    } finally {
                        backendWarmPromise = null;
                    }
                })();

                return backendWarmPromise;
            } catch (err) {
                return { ok: false, error: err?.message || String(err) };
            }
        }

        // Elements
        const mainWrap = document.getElementById('mainWrap');
        const cashWrap = document.getElementById('cashWrap');
        const tenderBox = document.getElementById('tenderBox');
        const btnCash = document.getElementById('btnCash');
        const btnCard = document.getElementById('btnCard');
        const btnScanNow = document.getElementById('btnScanNow');
        const visualRoot = document.getElementById('visualRoot');
        const ghostInput = document.getElementById('ghostInput');
        const scanNowWrap = document.getElementById('scanNowWrap');
        const debugStatus = document.getElementById('debugStatus');
        const btnQuickExact = document.getElementById('btnQuickExact');
        const btnQuickNextDollar = document.getElementById('btnQuickNextDollar');
        const btnQuickNextFive = document.getElementById('btnQuickNextFive');
        const btnCompleteSale = document.getElementById('btnCompleteSale');
        const debugFab = document.getElementById('debugFab');
        const debugSale = document.getElementById('debugSale');
        const debugFocus = document.getElementById('debugFocus');
        const debugGhostLen = document.getElementById('debugGhostLen');
        const debugBufLen = document.getElementById('debugBufLen');
        const debugState = document.getElementById('debugState');
        const debugFields = document.getElementById('debugFields');
        const debugSaleSource = document.getElementById('debugSaleSource');

        try {
            // Some iOS webviews are more reliable when the focused element is a normal text field.
            ghostInput.setAttribute('inputmode', 'text');
            ghostInput.setAttribute('enterkeyhint', 'done');
            ghostInput.setAttribute('autocomplete', 'off');
            ghostInput.setAttribute('autocorrect', 'off');
            ghostInput.setAttribute('autocapitalize', 'off');
            ghostInput.setAttribute('spellcheck', 'false');
        } catch (e) { }

        // iOS/iPadOS: keep a normal text inputmode for HID scanners.
        // In verify-only mode inside the Lightspeed iframe, prefer readonly capture (no on-screen keyboard),
        // and buffer keystrokes via keydown.
        if (verifyOnlyMode && embeddedMode) {
            try { ghostInput.setAttribute('inputmode', 'text'); } catch (e) { }
            if (preferReadOnlyCapture) {
                try { ghostInput.readOnly = true; ghostInput.setAttribute('readonly', ''); } catch (e) { }
            }
        }

        // When loaded as a Lightspeed gateway (iframe), remove the close button to prevent premature exits.
        if (embeddedMode) {
            lsSetup(false);
            // Request DATA to (1) resolve the correct event.origin on iOS/webview variants and
            // (2) capture register_sale/payment ids if present.
            lsData();
        }

        function toggleDebug() {
            document.body.classList.toggle('debug-ui');
            document.body.classList.toggle('show-keys');
            if (document.body.classList.contains('debug-ui')) remoteTelemetryEnabled = true;
            clientLog('debug toggled', { debugUi: document.body.classList.contains('debug-ui'), showKeys: document.body.classList.contains('show-keys') });
        }

        if (debugFab) {
            debugFab.addEventListener('click', (e) => {
                e.preventDefault();
                toggleDebug();
            });
        }

        function focusGhostInput(reason = 'focus') {
            try {
                if (!ghostInput) return false;

                // Default: keep it simple (editable focused field). This is the most reliable path for Bluetooth HID
                // scanners in iPad/WKWebView. Optional readonly focus hack can be enabled via query param.
                if (isIOSLike && noKeyboardHackEnabled) {
                    try { ghostInput.readOnly = true; ghostInput.setAttribute('readonly', ''); } catch (e) { }
                    try { ghostInput.click(); } catch (e) { }
                    ghostInput.focus({ preventScroll: true });
                    setTimeout(() => {
                        try { ghostInput.readOnly = false; ghostInput.removeAttribute('readonly'); } catch (e) { }
                        try { ghostInput.focus({ preventScroll: true }); } catch (e) { }
                    }, 0);
                } else {
                    try { ghostInput.readOnly = false; ghostInput.removeAttribute('readonly'); } catch (e) { }
                    try { ghostInput.click(); } catch (e) { }
                    ghostInput.focus({ preventScroll: true });
                }

                // Some webviews won't accept keystrokes unless there is an active caret/selection.
                try {
                    const len = String(ghostInput.value || '').length;
                    ghostInput.setSelectionRange(len, len);
                } catch (e) { }

                clientLog('focusGhostInput', { reason, active: document.activeElement === ghostInput });
                return true;
            } catch (e) {
                clientLog('focusGhostInput failed', { reason });
                return false;
            }
        }

        ghostInput.addEventListener('blur', () => {
            if (!isScanning) return;
            setTimeout(() => focusGhostInput('blur'), 50);
        });

        // Long-press the logo to toggle debug (works even when query params are stripped by the iframe host).
        (function installLogoDebugHold() {
            const logoRoot = document.getElementById('visualRoot');
            if (!logoRoot) return;
            let timer = null;
            const clear = () => { if (timer) clearTimeout(timer); timer = null; };
            const start = () => {
                clear();
                timer = setTimeout(() => {
                    toggleDebug();
                    clear();
                }, 900);
            };
            logoRoot.addEventListener('pointerdown', start);
            logoRoot.addEventListener('pointerup', clear);
            logoRoot.addEventListener('pointercancel', clear);
            logoRoot.addEventListener('pointerleave', clear);
        })();

        // iPad/WKWebView quirk: bluetooth HID keystrokes may not route into the iframe until the user has
        // performed at least one gesture *inside the iframe*. The TEST PING button was unintentionally acting
        // as that gesture. Track any pointerdown and opportunistically re-focus the ghost input while scanning.
        document.addEventListener('pointerdown', () => {
            lastUserGestureAtMs = Date.now();
            if (isScanning) {
                focusGhostInput('pointerdown');
            }
        }, { capture: true });

        document.addEventListener('pointerup', () => {
            lastUserGestureAtMs = Date.now();
            if (isScanning) {
                focusGhostInput('pointerup');
            }
        }, { capture: true });

        document.addEventListener('touchend', () => {
            if (window.PointerEvent) return;
            lastUserGestureAtMs = Date.now();
            if (isScanning) {
                focusGhostInput('touchend');
            }
        }, { capture: true, passive: true });

        window.addEventListener('message', (event) => {
            if (!event || typeof event.data !== 'string') return;
            let data = null;
            try {
                data = JSON.parse(event.data);
            } catch (e) {
                return;
            }

            if (!resolvedLightspeedOrigin && event.origin && event.origin !== 'null') {
                resolvedLightspeedOrigin = event.origin;
            }

            if (data && data.step === 'DATA') {
                // Lightspeed gateway DATA includes both:
                // - register_sale.id (gateway/register context id)
                // - register_sale.client_sale_id (the actual Lightspeed /sales/{id} identifier)
                // For API updates (sale note + customer updates), we must prefer client_sale_id when present.
                const maybeSaleId = data?.register_sale?.client_sale_id || data?.register_sale?.id || null;
                const maybeRefId = data?.payment?.reference_id || null;
                if (maybeRefId && !paymentReferenceId) {
                    paymentReferenceId = maybeRefId;
                }
                if (maybeSaleId) {
                    const nextSaleId = String(maybeSaleId || '').trim();
                    const currentSaleId = String(saleId || '').trim();

                    const shouldUpdateFromData =
                        !currentSaleId ||
                        saleIdSource === 'query:reference' ||
                        saleIdSource === 'query:reference_id' ||
                        saleIdSource === 'query:transaction_id' ||
                        (currentSaleId && nextSaleId && currentSaleId !== nextSaleId);

                    if (shouldUpdateFromData) {
                        const priorSaleId = currentSaleId || null;
                        saleId = maybeSaleId;
                        saleIdSource = data?.register_sale?.client_sale_id ? 'DATA:register_sale.client_sale_id' : 'DATA:register_sale.id';
                        pageOpenedAtMs = Date.now();
                        scanArmedAtMs = null;
                        latestVerificationId = null;
                        pendingVerifyPayload = null;
                        scanLocked = false;
                        isProcessingScan = false;
                        // If the iframe is reused across sales, ensure we reset overlays and buffers.
                        try { resetUI(); } catch (e) { }
                        clientLog('saleId set from DATA', { saleId, priorSaleId });
                        if (debugSale) debugSale.textContent = saleId || 'MISSING';
                    }
                } else if (!saleId && maybeRefId) {
                    saleId = maybeRefId;
                    saleIdSource = 'DATA:payment.reference_id';
                    clientLog('saleId set from DATA ref', { saleId });
                    if (debugSale) debugSale.textContent = saleId || 'MISSING';
                }

                if (saleId && pendingVerifyPayload && isScanning && !isProcessingScan) {
                    const payload = pendingVerifyPayload;
                    pendingVerifyPayload = null;
                    setTimeout(() => processScan(payload), 0);
                }
            }
        }, false);

        // Tender Selection
        function selectTender(type) {
            selectedTender = type;
            if (btnCash) btnCash.classList.toggle('selected', type === 'cash');
            if (btnCard) btnCard.classList.toggle('selected', type === 'card');
            btnScanNow.classList.add('ready');
            if (scanNowWrap) scanNowWrap.classList.add('ready');
            try { if (ghostInput) ghostInput.disabled = false; } catch (e) { }
            try {
                const target = type === 'cash' ? btnCash : btnCard;
                if (target) gsap.fromTo(target, { scale: 0.95 }, { scale: 1, duration: 0.4, ease: "elastic.out(1, 0.3)" });
            } catch (e) { }
        }

        if (btnCash) btnCash.onclick = () => selectTender('cash');
        if (btnCard) btnCard.onclick = () => selectTender('card');

        if (verifyOnlyMode) {
            const title = document.getElementById('mainTitle');
            const subtitle = document.getElementById('mainSubtitle');
            if (title) title.textContent = 'Verify Age';
            if (subtitle) subtitle.textContent = autoStartScan ? 'Focus on the barcode until it confirms.' : 'Tap to start scanning.';
            if (tenderBox) tenderBox.style.display = 'none';
            if (cashWrap) cashWrap.style.display = 'none';
            selectedTender = 'card';
            if (btnScanNow) btnScanNow.classList.add('ready');
            if (scanNowWrap) scanNowWrap.classList.add('ready');
            try { if (ghostInput) ghostInput.disabled = false; } catch (e) { }
            setIdleScanButtonText();
            clientLog('verifyOnlyMode enabled', { embeddedMode: embeddedMode });
        } else {
            setIdleScanButtonText();
        }

        function normalizeScanText(text) {
            return String(text || '')
                .replace(/\r\n/g, '\n')
                .replace(/[\r\n]/g, '\n')
                .replace(/[\x1c-\x1f]/g, '\n')
                .replace(/[\x00-\x08\x0b\x0c\x0e-\x1b]/g, '');
        }

        function hasAamvaField(text, field) {
            const normalized = normalizeScanText(text);
            const re = new RegExp(`${field}([^\\n]{1,64})`, 'i');
            return re.test(normalized);
        }

        function parseDobFromAamva(normalizedText) {
            try {
                const normalized = normalizeScanText(normalizedText);
                const match = normalized.match(/DBB[^0-9]*([0-9]{8}|[0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}\/[0-9]{2}\/[0-9]{4})/i);
                if (!match || !match[1]) return null;

                const raw = String(match[1]).trim();
                const now = new Date();
                const maxYear = now.getFullYear();
                const minYear = maxYear - 120;

                const makeDate = (year, month, day) => {
                    const y = Number(year);
                    const m = Number(month);
                    const d = Number(day);
                    if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
                    if (y < minYear || y > maxYear) return null;
                    if (m < 1 || m > 12) return null;
                    if (d < 1 || d > 31) return null;

                    const date = new Date(y, m - 1, d);
                    if (Number.isNaN(date.getTime())) return null;
                    if (date.getFullYear() !== y || date.getMonth() !== (m - 1) || date.getDate() !== d) return null;
                    return date;
                };

                // YYYY-MM-DD
                const iso = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                if (iso) {
                    const date = makeDate(iso[1], iso[2], iso[3]);
                    if (date) return date;
                }

                // MM/DD/YYYY
                const slash = raw.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
                if (slash) {
                    const date = makeDate(slash[3], slash[1], slash[2]);
                    if (date) return date;
                }

                // 8 digits: YYYYMMDD or MMDDYYYY
                const digits = (raw.match(/\d/g) || []).join('');
                if (digits.length >= 8) {
                    const raw8 = digits.substring(0, 8);
                    const startsWithYear = raw8.startsWith('19') || raw8.startsWith('20');
                    const endsWithYear = raw8.substring(4, 8).startsWith('19') || raw8.substring(4, 8).startsWith('20');

                    if (startsWithYear) {
                        const date = makeDate(raw8.substring(0, 4), raw8.substring(4, 6), raw8.substring(6, 8));
                        if (date) return date;
                    }

                    if (endsWithYear) {
                        const date = makeDate(raw8.substring(4, 8), raw8.substring(0, 2), raw8.substring(2, 4));
                        if (date) return date;
                    }
                }

                return null;
            } catch (e) {
                return null;
            }
        }

        function extractAamvaFieldLast(text, field, maxLen = 96) {
            try {
                const normalized = normalizeScanText(text);
                const re = new RegExp(`${field}([^\\n]{1,${Math.max(8, Math.min(128, maxLen))}})`, 'ig');
                let last = null;
                const matches = normalized.matchAll(re);
                for (const m of matches) {
                    if (m && m[1]) last = String(m[1]).trim();
                }
                return last || null;
            } catch (e) {
                return null;
            }
        }

        function sanitizeFieldValue(value, maxLen = 120) {
            if (!value) return null;
            const trimmed = String(value)
                .replace(/[\x00-\x08\x0b\x0c\x0e-\x1f]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            if (!trimmed) return null;
            return trimmed.substring(0, Math.max(1, maxLen));
        }

        function normalizeDocForCompare(value) {
            const sanitized = sanitizeFieldValue(value, 64);
            if (!sanitized) return null;
            const normalized = sanitized.replace(/[^0-9a-z]/gi, '').toUpperCase();
            return normalized || null;
        }

        function isCredibleDocumentNumber(value) {
            const normalized = normalizeDocForCompare(value);
            if (!normalized) return false;
            // Guard against partial/garbled DAQ fragments (common when iOS drops characters at high speed).
            // Most US DL numbers are >= 6 chars; keeping this threshold prevents approving banned customers
            // with an incomplete doc number.
            return normalized.length >= 6;
        }

        function isSameDate(a, b) {
            try {
                if (!(a instanceof Date) || !(b instanceof Date)) return false;
                return a.getFullYear() === b.getFullYear() &&
                    a.getMonth() === b.getMonth() &&
                    a.getDate() === b.getDate();
            } catch (e) {
                return false;
            }
        }

        let collected = null;
        let collectedScanAttempts = 0;

        function resetCollectedFields() {
            collected = {
                documentNumber: null,
                dob: null,
                firstName: null,
                lastName: null,
                sex: null,
                issuingCountry: null,
                documentExpiry: null,
                postalCode: null,
                address1: null,
                address2: null,
                city: null,
                state: null
            };
            collectedScanAttempts = 0;
        }

        function harvestFieldsFromText(text) {
            if (!collected) resetCollectedFields();
            collectedScanAttempts += 1;

            const normalized = normalizeScanText(text);

            const nextDoc = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAQ', 64), 64);
            const dob = parseDobFromAamva(normalized);

            // If DOB changes mid-session, assume a different customer's ID and reset.
            if (dob && collected.dob && !isSameDate(dob, collected.dob)) {
                resetCollectedFields();
                collected.dob = dob;
                if (nextDoc) collected.documentNumber = nextDoc;
            } else if (dob && !collected.dob) {
                collected.dob = dob;
            }

            if (nextDoc) {
                const currentRaw = collected.documentNumber;
                const currentNorm = normalizeDocForCompare(currentRaw);
                const nextNorm = normalizeDocForCompare(nextDoc);

                if (!currentNorm) {
                    collected.documentNumber = nextDoc;
                } else if (nextNorm && nextNorm === currentNorm) {
                    // Prefer the longer/raw value if they normalize the same (some scanners add spaces/suffixes).
                    if (String(nextDoc).length > String(currentRaw || '').length) {
                        collected.documentNumber = nextDoc;
                    }
                } else if (nextNorm) {
                    // If either doc is short OR one is a prefix of the other, treat as partial and keep the best/longest.
                    const partial =
                        currentNorm.length < 6 ||
                        nextNorm.length < 6 ||
                        currentNorm.startsWith(nextNorm) ||
                        nextNorm.startsWith(currentNorm);

                    if (partial) {
                        if (nextNorm.length > currentNorm.length) {
                            collected.documentNumber = nextDoc;
                        }
                    } else {
                        // Two credible-but-different IDs => new customer scan.
                        resetCollectedFields();
                        collected.documentNumber = nextDoc;
                        if (dob) collected.dob = dob;
                    }
                }
            }

            const nextFirst = sanitizeFieldValue(
                extractAamvaFieldLast(normalized, 'DAC', 80) || extractAamvaFieldLast(normalized, 'DCT', 80),
                80
            );
            const nextLast = sanitizeFieldValue(
                extractAamvaFieldLast(normalized, 'DCS', 80) || extractAamvaFieldLast(normalized, 'DCP', 80),
                80
            );
            const fullName = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAA', 120), 120);

            if (!collected.firstName && nextFirst) collected.firstName = nextFirst;
            if (!collected.lastName && nextLast) collected.lastName = nextLast;

            // If only full name is available, derive last/first from "LAST,FIRST" (common AAMVA format).
            if (fullName && (!collected.firstName || !collected.lastName)) {
                const parts = fullName.split(',');
                const maybeLast = sanitizeFieldValue(parts[0] || null, 80);
                const maybeFirst = sanitizeFieldValue(parts[1] || null, 80);
                if (!collected.lastName && maybeLast) collected.lastName = maybeLast;
                if (!collected.firstName && maybeFirst) collected.firstName = maybeFirst;
            }

            // Optional fields for customer fill
            const nextSex = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DBC', 4), 4);
            if (!collected.sex && nextSex) collected.sex = nextSex;

            const nextCountry = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DCG', 10) || 'USA', 10);
            if (!collected.issuingCountry && nextCountry) collected.issuingCountry = nextCountry;

            const nextExpiry = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DBA', 16), 16);
            if (!collected.documentExpiry && nextExpiry) collected.documentExpiry = nextExpiry;

            const nextPostal = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAK', 18), 18);
            if (!collected.postalCode && nextPostal) collected.postalCode = nextPostal;

            const nextAddr1 = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAG', 96), 96);
            const nextAddr2 = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAH', 96), 96);
            const nextCity = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAI', 64), 64);
            const nextState = sanitizeFieldValue(extractAamvaFieldLast(normalized, 'DAJ', 32), 32);

            if (!collected.address1 && nextAddr1) collected.address1 = nextAddr1;
            if (!collected.address2 && nextAddr2) collected.address2 = nextAddr2;
            if (!collected.city && nextCity) collected.city = nextCity;
            if (!collected.state && nextState) collected.state = nextState;
        }

        function getCollectedProgress() {
            if (!collected) resetCollectedFields();
            const hasDob = Boolean(collected.dob);
            const hasId = isCredibleDocumentNumber(collected.documentNumber);
            const hasName = Boolean(collected.firstName) && Boolean(collected.lastName);
            const hasAddr = Boolean(collected.address1) || Boolean(collected.city) || Boolean(collected.state) || Boolean(collected.postalCode);
            return { hasDob, hasId, hasName, hasAddr, attempts: collectedScanAttempts };
        }

        function buildSyntheticPayloadFromCollected() {
            if (!collected) return '';
            const lines = [];

            // Core identity fields
            if (collected.lastName) lines.push(`DCS${collected.lastName}`);
            if (collected.firstName) lines.push(`DAC${collected.firstName}`);
            if (collected.dob instanceof Date && !Number.isNaN(collected.dob.getTime())) {
                const y = collected.dob.getFullYear();
                const m = String(collected.dob.getMonth() + 1).padStart(2, '0');
                const d = String(collected.dob.getDate()).padStart(2, '0');
                lines.push(`DBB${y}${m}${d}`);
            }
            if (collected.documentNumber) lines.push(`DAQ${collected.documentNumber}`);

            // Optional profile fields
            if (collected.sex) lines.push(`DBC${collected.sex}`);
            if (collected.issuingCountry) lines.push(`DCG${collected.issuingCountry}`);
            if (collected.documentExpiry) lines.push(`DBA${collected.documentExpiry}`);
            if (collected.address1) lines.push(`DAG${collected.address1}`);
            if (collected.address2) lines.push(`DAH${collected.address2}`);
            if (collected.city) lines.push(`DAI${collected.city}`);
            if (collected.state) lines.push(`DAJ${collected.state}`);
            if (collected.postalCode) lines.push(`DAK${collected.postalCode}`);

            return lines.join('\n');
        }

        function ingestScanAttempt(text) {
            const raw = String(text || '');
            if (raw.trim().length < 20) {
                return { satisfied: false, progress: getCollectedProgress(), reason: 'too_short' };
            }

            harvestFieldsFromText(raw);
            const progress = getCollectedProgress();

            // Required for verification: DOB + document id.
            // Name/address are collected opportunistically and included when available.
            if (progress.hasDob && progress.hasId) {
                const payload = buildSyntheticPayloadFromCollected();
                return { satisfied: true, payload, progress };
            }

            return { satisfied: false, progress, reason: 'missing_fields' };
        }

        function formatCollectedProgress(progress) {
            const p = progress || getCollectedProgress();
            const yn = (v) => (v ? 'Y' : 'N');
            return `DOB ${yn(p.hasDob)}  ID ${yn(p.hasId)}  NAME ${yn(p.hasName)}  (tries ${p.attempts})`;
        }

        function clearAttemptBuffer({ keepPreview = false } = {}) {
            barcodeBuffer = '';
            remoteProgressNextLen = 50;
            try { if (ghostInput) ghostInput.value = ''; } catch (e) { }
            if (!keepPreview) {
                updateScanPreview('');
            }
        }

        function flushVerifyOnlyAttempt(reason = 'timeout') {
            if (!verifyOnlyMode) return false;
            if (!isScanning || scanLocked || isProcessingScan) return false;

            // Prevent duplicate flush (idle + timeout) for the same attempt.
            try {
                if (scanIdleTimer) { clearTimeout(scanIdleTimer); scanIdleTimer = null; }
                if (scanTimer) { clearTimeout(scanTimer); scanTimer = null; }
            } catch (e) { }

            // Prefer the live input value over the buffered copy: on iPad/WKWebView the final characters
            // (especially the terminator) can land in `ghostInput.value` slightly after our `barcodeBuffer`
            // snapshot, which caused a "full-looking" scan to be treated as incomplete and cleared.
            const raw = String(((ghostInput && ghostInput.value) || barcodeBuffer || ''));
            const trimmed = raw.trim();

            // First, try to verify directly from this single scan buffer.
            // This avoids forcing a second scan when the first scan already includes the required AAMVA fields.
            try {
                const progressDirect = getVerifyProgress(trimmed);
                if (progressDirect.hasDob && progressDirect.hasId && trimmed.length >= 40) {
                    if (debugStatus) debugStatus.textContent = 'VERIFYING: Checking ID...';
                    finalizeScan(trimmed);
                    return true;
                }
            } catch (e) { }

            // If direct parsing fails (due to separators/control chars) but the scan clearly contains the core
            // AAMVA tokens, submit it anyway and let the backend do the authoritative parsing/banned check.
            try {
                const normalized = normalizeScanText(trimmed);
                const hasCoreTokens = /DBB/i.test(normalized) && /DAQ/i.test(normalized);
                if (hasCoreTokens && trimmed.length >= 120) {
                    if (debugStatus) debugStatus.textContent = 'VERIFYING: Checking ID...';
                    finalizeScan(trimmed);
                    return true;
                }
            } catch (e) { }

            // Otherwise, fall back to the multi-scan collector (handles partial/overlapping scans).
            const result = ingestScanAttempt(trimmed);

            try {
                reportRemoteError(
                    'SCAN_ATTEMPT_CLIENT',
                    { reason, len: trimmed.length, ...result.progress },
                    'CLIENT_LOG'
                );
            } catch (e) { }

            if (result.satisfied && result.payload) {
                if (debugStatus) debugStatus.textContent = 'VERIFYING: Checking ID...';
                finalizeScan(result.payload);
                return true;
            }

            if (debugStatus) debugStatus.textContent = `LISTENING: ${formatCollectedProgress(result.progress)} - keep scanning`;
            clearAttemptBuffer();
            return false;
        }

        function getVerifyProgress(text) {
            const normalized = normalizeScanText(text);
            const hasDob = Boolean(parseDobFromAamva(normalized));
            const hasId = hasAamvaField(normalized, 'DAQ') || (hasAamvaField(normalized, 'DCS') && hasAamvaField(normalized, 'DAC'));
            const hasAddr =
                hasAamvaField(normalized, 'DAG') ||
                hasAamvaField(normalized, 'DAI') ||
                hasAamvaField(normalized, 'DAJ') ||
                hasAamvaField(normalized, 'DAK');
            return { hasDob, hasId, hasAddr, normalized };
        }

        function extractLikelyScanSegment(text) {
            const raw = String(text || '');
            const idxAnsi = raw.lastIndexOf('@ANSI');
            if (idxAnsi >= 0) return raw.slice(idxAnsi);
            const idxAt = raw.lastIndexOf('@');
            if (idxAt >= 0) return raw.slice(idxAt);
            return raw;
        }

        function isScanSatisfied(text) {
            const { hasId, normalized } = getVerifyProgress(text);
            const dob = parseDobFromAamva(normalized);

            // Only submit once DOB parses cleanly (prevents partial/garbled payloads that cause "Could not read DOB").
            if (!dob || !hasId) return false;

            // Avoid early submits when scanners pause mid-payload: wait for a reasonably complete AAMVA length.
            const looksLikeAamva =
                normalized.includes('@ANSI') ||
                normalized.includes('ANSI ') ||
                normalized.includes('AAMVA') ||
                /DAQ/i.test(normalized) ||
                /DBB/i.test(normalized);

            if (looksLikeAamva) return normalized.length >= 200;
            return normalized.length >= 260;
        }

        const SCAN_HARD_TIMEOUT_MS = 30000;
        const SCAN_IDLE_TIMEOUT_MS = 900;
        // In verify-only mode, use the same proven "timer-delimited buffer" approach from the older gateway:
        // keep buffering characters until there's a quiet period, then submit.
        // Slightly longer than the original to reduce premature flush on scanners that pause mid-payload.
        const SCAN_TIMEOUT_MS = 2500;
        let scanTimer = null;
        const subtitleEl = document.getElementById('mainSubtitle');
        const defaultSubtitleText = subtitleEl ? subtitleEl.textContent : '';
        let lastKeyAt = 0;
        let hasShownArmHint = false;
        let verifyOnlyKeyCaptureSeen = false;

        function clearScanTimers() {
            if (scanIdleTimer) clearTimeout(scanIdleTimer);
            if (scanHardTimer) clearTimeout(scanHardTimer);
            if (scanTimer) clearTimeout(scanTimer);
            scanIdleTimer = null;
            scanHardTimer = null;
            scanTimer = null;
        }

        function resetScanCaptureState({ keepPreview = false } = {}) {
            barcodeBuffer = '';
            scanLocked = false;
            remoteProgressNextLen = 50;
            clearScanTimers();
            if (ghostInput) ghostInput.value = '';
            if (!keepPreview) {
                updateScanPreview('');
            }
        }

        function updateScanPreview(text) {
            try {
                const preview = document.getElementById('scanPreviewText');
                if (!preview) return;
                const value = String(text || '');

                if (debugKeysEnabled) {
                    const display = value.length > 240 ? '...' + value.slice(-240) : value;
                    preview.textContent = display || '...';
                    return;
                }

                if (maskKeysEnabled) {
                    const len = value.length;
                    if (!len) {
                        preview.textContent = '...';
                        return;
                    }
                    const shown = Math.min(120, len);
                    preview.textContent = `${'*'.repeat(shown)} (${len})`;
                    return;
                }

                // Default: keep hidden in UI, but avoid leaking raw text if it is ever shown.
                preview.textContent = value ? `(capturing ${value.length} chars)` : '...';
            } catch (e) { }
        }

        function setScanCtaText() {
            btnScanNow.innerHTML = '<span class="scan-dot"></span> Focus on barcode until verified';
        }

        function setTapToStartText() {
            btnScanNow.innerHTML = '<span class="scan-dot"></span> Tap to start scanning';
        }

        function setIdleScanButtonText() {
            if (verifyOnlyMode) {
                if (autoStartScan) setScanCtaText();
                else setTapToStartText();
                return;
            }
            btnScanNow.innerHTML = '<span class="scan-dot"></span> Scan Now';
        }

        function scheduleIdleCheck() {
            if (scanIdleTimer) clearTimeout(scanIdleTimer);
            scanIdleTimer = setTimeout(() => {
                if (!isScanning || scanLocked) return;
                const candidate = extractLikelyScanSegment(barcodeBuffer);
                const trimmed = String(candidate || '').trim();
                const looksLikePdf417 =
                    trimmed.includes('@ANSI') ||
                    trimmed.includes(']L') ||
                    /DAQ/i.test(trimmed) ||
                    /DBB/i.test(trimmed);

                if (verifyOnlyMode) {
                    return;
                }

                if (isScanSatisfied(trimmed) || (looksLikePdf417 && trimmed.length >= 40) || trimmed.length >= 140) {
                    finalizeScan(trimmed);
                    return;
                }

                if (debugStatus) {
                    debugStatus.textContent = verifyOnlyMode
                        ? 'LISTENING: Focus on the barcode…'
                        : 'WAITING: Scan again (tap once to arm if needed)';
                }
            }, SCAN_IDLE_TIMEOUT_MS);
        }

        function startHardTimeout() {
            if (scanHardTimer) return;
            scanHardTimer = setTimeout(() => {
                if (!isScanning || scanLocked) return;
                if (verifyOnlyMode) {
                    resumeListening('TIMEOUT: Scan again.');
                    return;
                }

                showError('Scan timed out. Keep the scanner on the barcode and try again.');
                isScanning = false;
                visualRoot.classList.remove('scanning');
                setIdleScanButtonText();
                resetScanCaptureState();
            }, SCAN_HARD_TIMEOUT_MS);
        }

        function finalizeScan(rawText) {
            if (scanLocked || isProcessingScan) return;
            scanLocked = true;
            clearScanTimers();

            const payload = extractLikelyScanSegment(rawText);
            try {
                const progress = getVerifyProgress(payload);
                reportRemoteError(
                    'SCAN_FINALIZE',
                    { len: String(payload || '').length, dob: progress.hasDob, id: progress.hasId, addr: progress.hasAddr },
                    'CLIENT_LOG'
                );
            } catch (e) { }
            processScan(payload);
            barcodeBuffer = '';
            if (ghostInput) ghostInput.value = '';
        }

        function armScan(reason = 'arm') {
            scanArmedAtMs = Date.now();
            lastUserGestureAtMs = Date.now();

            try {
                reportRemoteError('ARM_SCAN', { reason, embeddedMode, isIOSLike, saleIdPresent: Boolean(saleId) }, 'CLIENT_LOG');
            } catch (e) { }

            // Warm the backend/DB in parallel (do not block keystroke capture).
            try {
                if (debugStatus) debugStatus.textContent = 'CONNECTING: Checking backend...';
                warmupBackend(reason).then((result) => {
                    if (!result || result.ok !== true) {
                        if (debugStatus) debugStatus.textContent = 'WARN: Backend not ready (will retry on verify).';
                        return;
                    }
                    if (debugStatus) debugStatus.textContent = 'READY: Focus on the barcode.';
                });
            } catch (e) { }

            function scheduleFocusBurst(baseReason) {
                try {
                    if (!isIOSLike || !embeddedMode) return;
                    const delays = [0, 40, 90, 160, 260, 420, 650, 900];
                    delays.forEach((delayMs) => {
                        setTimeout(() => {
                            if (!isScanning || scanLocked || isProcessingScan) return;
                            if (document.activeElement === ghostInput) return;
                            focusGhostInput(`${baseReason}-burst-${delayMs}`);
                        }, delayMs);
                    });
                } catch (e) { }
            }

            // If already armed, don't clear buffer accidentally; just refocus.
            if (isScanning && !isProcessingScan && !scanLocked) {
                const quietForMs = lastKeyAt ? (Date.now() - lastKeyAt) : Number.POSITIVE_INFINITY;
                if (quietForMs > 500) resetScanCaptureState({ keepPreview: false });
                focusGhostInput(reason + '-rearm');
                scheduleFocusBurst(reason + '-rearm');
                setScanCtaText();
                if (subtitleEl && verifyOnlyMode) subtitleEl.textContent = defaultSubtitleText || 'Focus on the barcode until it confirms.';
                clientLog('scan re-armed', { reason });
                return;
            }

            // New arming session: reset multi-scan collected fields.
            try { resetCollectedFields(); } catch (e) { }

            isScanning = true;
            isProcessingScan = false;
            visualRoot.classList.add('scanning');
            setScanCtaText();
            if (debugStatus) debugStatus.textContent = verifyOnlyMode ? 'LISTENING: Focus on the barcode.' : 'LISTENING: Scan ID.';
            if (subtitleEl && verifyOnlyMode) subtitleEl.textContent = defaultSubtitleText || 'Focus on the barcode until it confirms.';
            try { if (ghostInput) ghostInput.disabled = false; } catch (e) { }
            resetScanCaptureState();
            try { if (verifyOnlyMode && ghostInput) ghostInput.placeholder = 'Focus on barcode until verified'; } catch (e) { }

            // Focus must happen inside a trusted gesture to route Bluetooth HID keystrokes in iPad webviews.
            focusGhostInput(reason);
            // Some webviews ignore the first focus; retry once while still in the same gesture stack.
            if (document.activeElement !== ghostInput) focusGhostInput(reason + '-retry');
            // Important: some iPad/WKWebView hosts steal focus *after* the tap/click completes (e.g., back to the button).
            // Do a short burst of post-gesture focus attempts to guarantee the hidden input ends up focused before the scan.
            scheduleFocusBurst(reason);

            clientLog('scan armed', { verifyOnlyMode, saleId: saleId || null, reason });
        }

        // Scan Activation
        // iPad/Lightspeed iframe: focusing must happen synchronously within a trusted user gesture.
        // Doing this on pointerdown (not just click) makes arming much more reliable.
        // IMPORTANT: the visible button is not clickable; the real tap target is the transparent input overlay (#ghostInput).
        if (ghostInput) {
            ghostInput.addEventListener('pointerdown', (e) => {
                // Do NOT preventDefault here: iPad/WKWebView is most reliable when the browser performs the native
                // "place caret in input" action for the tap.
                try { e.stopPropagation(); } catch (err) { }
                armScan('ghostInput-pointerdown');
            }, { capture: true });

            ghostInput.addEventListener('touchstart', (e) => {
                if (window.PointerEvent) return;
                try { e.stopPropagation(); } catch (err) { }
                armScan('ghostInput-touchstart');
            }, { capture: true, passive: false });

            ghostInput.addEventListener('click', (e) => {
                try { e.stopPropagation(); } catch (err) { }
                if (isScanning) focusGhostInput('ghostInput-click-refocus');
            }, { capture: true });
        }

        btnScanNow.addEventListener('pointerdown', () => armScan('btnScanNow-pointerdown'), { capture: true });
        btnScanNow.addEventListener('touchstart', () => {
            if (window.PointerEvent) return;
            armScan('btnScanNow-touchstart');
        }, { capture: true, passive: true });
        btnScanNow.addEventListener('pointerup', () => {
            lastUserGestureAtMs = Date.now();
            if (isScanning) focusGhostInput('btnScanNow-pointerup');
        }, { capture: true });
        btnScanNow.addEventListener('touchend', () => {
            if (window.PointerEvent) return;
            lastUserGestureAtMs = Date.now();
            if (isScanning) focusGhostInput('btnScanNow-touchend');
        }, { capture: true, passive: true });

        btnScanNow.onclick = () => {
            // If a pointerdown/touchstart just armed the scan, ignore the follow-up click.
            const now = Date.now();
            if (scanArmedAtMs && (now - scanArmedAtMs) < 450) {
                // iOS/webviews often steal focus back onto the button at click-time; refocus here.
                focusGhostInput('btnScanNow-click-refocus');
                try { btnScanNow.blur(); } catch (e) { }
                return;
            }
            armScan('btnScanNow-click');
            if (debugStatus) debugStatus.textContent = verifyOnlyMode ? 'LISTENING: Focus on the barcode…' : 'LISTENING: Scan ID…';
            if (subtitleEl && verifyOnlyMode) subtitleEl.textContent = defaultSubtitleText || 'Focus on the barcode until it confirms.';
        };

        if (autoStartScan) {
            // Auto-start listening for barcode input when this page is used as a "Verify ID" button.
            // Small delay avoids focus issues on iPad webviews.
            setTimeout(() => {
                try {
                    btnScanNow.onclick();
                    clientLog('autoStartScan fired');
                } catch (e) { }
            }, 50);
        }

        // If iOS/Lightspeed refuses to focus a hidden input, staff can tap the Scan button again to re-arm.

        // Ghost Focus Loop
        setInterval(() => {
            if (isScanning && document.activeElement !== ghostInput) {
                focusGhostInput('interval');
            }
        }, 500);

        // Extra focus attempts right after load: iOS/Lightspeed webviews can ignore the first focus call.
        (function focusBurst() {
            let attempts = 0;
            const maxAttempts = 16; // ~2s at 125ms intervals
            const tick = () => {
                attempts += 1;
                if (attempts > maxAttempts) return;
                if (!isScanning) return;
                if (document.activeElement === ghostInput) return;
                focusGhostInput(`burst-${attempts}`);
                setTimeout(tick, 125);
            };
            setTimeout(tick, 125);
        })();

        window.addEventListener('focus', () => {
            if (isScanning) focusGhostInput('window-focus');
        });

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && isScanning) focusGhostInput('visibility');
        });

        function handleBufferChanged() {
            barcodeBuffer = String(ghostInput.value || '');
            if (barcodeBuffer.length > 6000) {
                barcodeBuffer = barcodeBuffer.slice(-6000);
                ghostInput.value = barcodeBuffer;
            }

            updateScanPreview(barcodeBuffer);

            const candidate = extractLikelyScanSegment(barcodeBuffer);
            if (!verifyOnlyMode && (candidate.includes('\n') || candidate.includes('\r')) && candidate.trim().length > 20) {
                finalizeScan(candidate);
                return;
            }
            if (!verifyOnlyMode && isScanSatisfied(candidate)) {
                finalizeScan(candidate);
                return;
            }

            scheduleIdleCheck();
        }

        function resumeListening(statusText = null) {
            isScanning = true;
            isProcessingScan = false;
            scanLocked = false;
            visualRoot.classList.add('scanning');
            setScanCtaText();
            btnScanNow.style.opacity = "1";
            btnScanNow.style.pointerEvents = "auto";
            try { if (ghostInput) ghostInput.disabled = false; } catch (e) { }
            resetScanCaptureState();
            focusGhostInput('resumeListening');
            try {
                if (isIOSLike && embeddedMode) {
                    setTimeout(() => { if (isScanning && document.activeElement !== ghostInput) focusGhostInput('resumeListening-burst-0'); }, 0);
                    setTimeout(() => { if (isScanning && document.activeElement !== ghostInput) focusGhostInput('resumeListening-burst-80'); }, 80);
                    setTimeout(() => { if (isScanning && document.activeElement !== ghostInput) focusGhostInput('resumeListening-burst-220'); }, 220);
                }
            } catch (e) { }
            if (debugStatus && statusText) debugStatus.textContent = statusText;
        }

        function handleKeyBuffered(key) {
            if (!isScanning || scanLocked) return;
            startHardTimeout();
            barcodeBuffer += key;

            try {
                if (barcodeBuffer.length >= remoteProgressNextLen) {
                    const progress = getVerifyProgress(barcodeBuffer);
                    reportRemoteError(
                        'SCAN_PROGRESS',
                        { len: barcodeBuffer.length, dob: progress.hasDob, id: progress.hasId, addr: progress.hasAddr },
                        'CLIENT_LOG'
                    );
                    remoteProgressNextLen += 50;
                }
            } catch (e) { }

            updateScanPreview(barcodeBuffer);

            if (verifyOnlyMode && key === '\n') {
                if (scanTimer) { clearTimeout(scanTimer); scanTimer = null; }
                flushVerifyOnlyAttempt('enter');
                return;
            }

            if (scanTimer) clearTimeout(scanTimer);
            scanTimer = setTimeout(() => {
                if (!isScanning || scanLocked) return;
                if (verifyOnlyMode) {
                    flushVerifyOnlyAttempt('timeout');
                    return;
                }

                const candidate = extractLikelyScanSegment(barcodeBuffer);
                const trimmed = String(candidate || '').trim();
                if (trimmed.length >= 40) {
                    finalizeScan(trimmed);
                    return;
                }

                barcodeBuffer = '';
            }, SCAN_TIMEOUT_MS);
        }

        function appendScanText(text) {
            if (!isScanning || scanLocked) return;
            startHardTimeout();
            lastKeyAt = Date.now();
            hasShownArmHint = false;

            ghostInput.value = (ghostInput.value || '') + text;
            handleBufferChanged();
        }

        function updateArmHint() {
            if (!verifyOnlyMode || !subtitleEl) return;
            if (!isScanning) return;

            const active = document.activeElement === ghostInput;
            const quietForMs = lastKeyAt ? (Date.now() - lastKeyAt) : Number.POSITIVE_INFINITY;

            // Dual-mode UX: try auto; if focus/key routing doesn't work, prompt to tap the Scan button.
            if (embeddedMode && autoStartScan && !manualOnlyTapToScan) {
                if (!active && quietForMs > 2500) {
                    setTapToStartText();
                } else {
                    setScanCtaText();
                }
            }
        }

        setInterval(updateArmHint, 400);

        document.addEventListener('touchstart', () => {
            if (!isScanning) return;
            focusGhostInput('touchstart');
        }, { passive: true });

        // iPad/Lightspeed WKWebView: a user gesture dramatically improves HID key routing.
        // Treat the first tap anywhere as an explicit "arm" action for focus.
        document.addEventListener('pointerdown', () => {
            if (!isScanning) return;
            focusGhostInput('pointerdown-gesture');
        }, { capture: true, passive: true });

        function keyToScanChar(e) {
            try {
                if (!e) return null;
                const key = e.key;
                if (key === 'Enter' || key === 'Tab') return '\n';
                if (key && key.length === 1) return key;

                const code = Number(e.which || e.keyCode || 0);
                if (code === 13 || code === 9) return '\n';
                if (code >= 32 && code <= 126) {
                    return String.fromCharCode(code);
                }
                return null;
            } catch (err) {
                return null;
            }
        }

        if (!verifyOnlyMode) {
            // Barcode listener: wait until required AAMVA fields are present (DBB + DAQ).
            ghostInput.addEventListener('keydown', (e) => {
                if (!isScanning || scanLocked) return;

                if (e.key === 'Tab') {
                    e.preventDefault();
                    appendScanText('\n');
                    return;
                }
            });

            // Primary capture path: let the scanner type into the hidden textarea and react on input events.
            ghostInput.addEventListener('input', () => {
                if (!isScanning || scanLocked) return;
                startHardTimeout();
                lastKeyAt = Date.now();
                hasShownArmHint = false;
                handleBufferChanged();
            });

            // Fallback capture path for iPad webviews that won't keep focus reliably.
            window.addEventListener('keydown', (e) => {
                if (!isScanning || scanLocked) return;
                if (document.activeElement === ghostInput) return;

                const ch = keyToScanChar(e);
                if (!ch) return;

                e.preventDefault();
                appendScanText(ch);
            }, true);
        } else {
            // Verify-only (iPad/Lightspeed): keep it BASIC and let the scanner type into the focused input.
            // We flush an "attempt" on Enter (CR) or on quiet-time.
            if (ghostInput) {
                ghostInput.addEventListener('keydown', (e) => {
                    if (scanLocked) return;
                    const ch = keyToScanChar(e);
                    if (!ch) return;
                    if (!isScanning) armScan('ghostInput-keydown');

                    // If readonly capture is enabled, the browser won't insert characters into the input.
                    // In that mode, buffer via keydown so HID scans still work and the iOS keyboard stays hidden.
                    if (ghostInput.readOnly) {
                        e.preventDefault();
                        handleKeyBuffered(ch);
                        return;
                    }

                    // Otherwise, let the browser insert the character into the input (most reliable).
                    // Give iPad/WKWebView a tiny window to commit the final characters to `.value` before we flush.
                    if (ch === '\n') setTimeout(() => flushVerifyOnlyAttempt('enter'), 40);
                }, true);

                ghostInput.addEventListener('input', () => {
                    if (!isScanning || scanLocked) return;
                    if (ghostInput.readOnly) return;
                    startHardTimeout();
                    lastKeyAt = Date.now();
                    hasShownArmHint = false;
                    barcodeBuffer = String(ghostInput.value || '');
                    updateScanPreview(barcodeBuffer);

                    if (scanTimer) clearTimeout(scanTimer);
                    scanTimer = setTimeout(() => {
                        if (!isScanning || scanLocked) return;
                        flushVerifyOnlyAttempt('timeout');
                    }, SCAN_TIMEOUT_MS);

                    // Also keep the shorter idle check alive for partial scans.
                    scheduleIdleCheck();
                });
            }
        }

        // Initialize debug info
        document.getElementById('debugUrl').textContent = window.location.pathname + window.location.search;
        document.getElementById('debugSale').textContent = saleId || 'MISSING';
        if (debugSaleSource) debugSaleSource.textContent = saleIdSource || 'unknown';

        setInterval(() => {
            try {
                if (debugSale) debugSale.textContent = saleId || 'MISSING';
                if (debugFocus) debugFocus.textContent = (document.activeElement === ghostInput) ? 'ghostInput' : (document.activeElement ? document.activeElement.tagName : 'none');
                if (debugGhostLen) debugGhostLen.textContent = String((ghostInput.value || '').length);
                if (debugBufLen) debugBufLen.textContent = String((barcodeBuffer || '').length);
                if (debugState) debugState.textContent = `scan=${isScanning ? 'ON' : 'OFF'} proc=${isProcessingScan ? '1' : '0'} lock=${scanLocked ? '1' : '0'}`;
                if (debugFields) {
                    const p = getCollectedProgress();
                    debugFields.textContent = `DOB ${p.hasDob ? 'Y' : 'N'} | ID ${p.hasId ? 'Y' : 'N'} | NAME ${p.hasName ? 'Y' : 'N'} | tries ${p.attempts}`;
                }
                if (debugSaleSource) debugSaleSource.textContent = saleIdSource || 'unknown';
            } catch (e) { }
        }, 250);

        // Polling for updates (for resilience and diagnostic logs)
        let pollInterval = null;
        function startPolling() {
            if (pollInterval) return;
            pollInterval = setInterval(async () => {
                if (!saleId) return;
                try {
                    const res = await fetch(`/api/sales/${encodeURIComponent(saleId)}/status?t=${Date.now()}`, {
                        headers: getApiHeaders()
                    });
                    if (!res.ok) return;
                    const data = await res.json();

                    // Update logs
                    if (data.logs && data.logs.length > 0) {
                        const logEl = document.getElementById('debugLogs');
                        logEl.innerHTML = data.logs.map(l => {
                            let color = '#fff';
                            if (l.type === 'error') color = '#ff4d4d';
                            if (l.type === 'warn') color = '#ffcc00';
                            return `<div style="color: ${color}; margin-bottom: 2px;">• ${l.message}</div>`;
                        }).join('');
                        logEl.scrollTop = logEl.scrollHeight;
                    }

                    // Auto-advance if verified by another device or background
                    if (data.status === 'approved' || data.status === 'approved_override') {
                        const updatedAtMs = Number(data.updatedAtMs || 0);
                        const minFreshMs = (scanArmedAtMs ?? pageOpenedAtMs);
                        if (updatedAtMs && updatedAtMs >= minFreshMs) {
                            clientLog('status approved (fresh)', { updatedAtMs, minFreshMs });
                            showSuccess(data);
                            clearInterval(pollInterval);
                            pollInterval = null;
                        } else {
                            // "Resume verified" for the SAME live sale: if we have high confidence the sale id came from
                            // Lightspeed DATA (register_sale.id), then a previously-approved verification should auto-pass.
                            const fromLightspeedData = String(saleIdSource || '').startsWith('DATA:register_sale.id');
                            if (fromLightspeedData) {
                                clientLog('status approved (resume)', { updatedAtMs, minFreshMs, saleIdSource });
                                showSuccess(data);
                                clearInterval(pollInterval);
                                pollInterval = null;
                            } else {
                                // Otherwise, treat it as stale to avoid false approvals from a wrong/stale identifier.
                                clientLog('status approved but stale', { updatedAtMs, minFreshMs, saleIdSource });
                                try { lsData(); } catch (e) { }
                            }
                        }
                    }
                } catch (e) { }
            }, 2000);
        }
        startPolling();

        // Warm backend/DB on load to reduce cold-start pain before the first scan.
        try { warmupBackend('page-load'); } catch (e) { }

        async function testConnectivity(ev) {
            const statusEl = document.getElementById('debugStatus');
            statusEl.textContent = 'PINGING SERVER...';
            statusEl.style.color = '#fff';

            try {
                const res = await fetch(`/api/debug/ping?t=${Date.now()}`, {
                    headers: getApiHeaders()
                });
                const data = await res.json();
                statusEl.textContent = `SUCCESS: DB=${data.db}`;
                statusEl.style.color = '#0f0';
            } catch (err) {
                statusEl.textContent = `ERROR: ${err.message}`;
                statusEl.style.color = '#f00';
            }
        }

        async function processScan(rawData) {
            if (!saleId) {
                // In Lightspeed iframe flows, the sale id can arrive via postMessage DATA shortly after load.
                // Keep listening and process the scan once we have context.
                pendingVerifyPayload = rawData;
                try { lsData(); } catch (e) { }
                if (debugStatus) debugStatus.textContent = 'WAITING: Linking to POS sale...';
                clientLog('missing saleId; requesting DATA', { len: String(rawData || '').length });
                scanLocked = false;
                isProcessingScan = false;
                isScanning = true;
                visualRoot.classList.add('scanning');
                return;
            }

            if (!isScanning || isProcessingScan) return; // Guard against double calls
            if (!scanArmedAtMs) scanArmedAtMs = Date.now();

            const isTerminalRejection = (reason) => {
                const r = String(reason || '').toLowerCase();
                return r.includes('underage') || r.includes('banned');
            };

            isProcessingScan = true;
            btnScanNow.innerHTML = '<span class="scan-dot" style="background: #f0ad4e"></span> Checking ID...';
            btnScanNow.style.opacity = "0.7";
            btnScanNow.style.pointerEvents = "none";
            try { if (ghostInput) ghostInput.disabled = true; } catch (e) { }
            if (debugStatus) debugStatus.textContent = 'PROCESSING: Checking ID...';
            clientLog('submitting verify', { saleId, len: String(rawData || '').length });
            try {
                reportRemoteError('VERIFY_REQUEST', { len: String(rawData || '').length }, 'CLIENT_LOG');
            } catch (e) { }

            try {
                const response = await fetch(`/api/sales/${encodeURIComponent(saleId)}/verify-bluetooth`, {
                    method: 'POST',
                    headers: getApiHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify({
                        barcodeData: rawData,
                        clerkId: clerkIdParam,
                        registerId: registerIdParam,
                        saleTotal: saleAmount
                    })
                });

                if (!response.ok) {
                    const errorJson = await response.json().catch(() => ({}));
                    const errorMsg = errorJson.technical || errorJson.message || response.statusText;
                    reportRemoteError('HTTP_ERROR', { status: response.status, statusText: response.statusText, response: errorJson });

                    // Scan-only mode should be resilient: treat most server errors as transient and keep listening.
                    // 401/403 usually indicate a configuration/auth issue; surface those as terminal.
                    if (verifyOnlyMode && response.status !== 401 && response.status !== 403) {
                        resumeListening(`SERVER ${response.status}: ${errorMsg}. Scan again.`);
                        return;
                    }

                    isScanning = false;
                    isProcessingScan = false;
                    showError(`Server Error (${response.status}): ${errorMsg}`);
                    return;
                }

                const data = await response.json();

                // Backend may resolve the POS gateway/register_sale id to the actual Retail sale id.
                // Use the resolved id for polling and any follow-up API calls.
                try {
                    const returnedSaleId = String(data.saleId || data.resolvedSaleId || '').trim();
                    if (returnedSaleId && returnedSaleId !== saleId) {
                        clientLog('saleId resolved', { from: saleId, to: returnedSaleId });
                        saleId = returnedSaleId;
                        const debugSaleEl = document.getElementById('debugSale');
                        if (debugSaleEl) debugSaleEl.textContent = saleId;
                    }
                } catch (e) { }

                clientLog('verify response', {
                    success: data.success,
                    approved: data.approved,
                    noteUpdated: data.noteUpdated,
                    saleFetchOk: data.saleFetchOk,
                    saleCustomerId: data.saleCustomerId ? 'present' : 'none',
                    customerUpdated: data.customerUpdated,
                    customerUpdateSkipped: data.customerUpdateSkipped || null
                });
                try {
                    reportRemoteError(
                        'VERIFY_RESPONSE',
                        {
                            success: Boolean(data.success),
                            approved: Boolean(data.approved),
                            noteUpdated: Boolean(data.noteUpdated),
                            dbSaved: Boolean(data.dbSaved),
                            saleFetchOk: Boolean(data.saleFetchOk),
                            customerUpdated: Boolean(data.customerUpdated),
                            customerUpdateSkipped: data.customerUpdateSkipped || null,
                            reason: data.reason || null
                        },
                        'CLIENT_LOG'
                    );
                } catch (e) { }

                if (data.success && data.approved) {
                    latestVerificationId = data.verificationId || data.verification_id || latestVerificationId;
                    isScanning = false;
                    isProcessingScan = false;
                    showSuccess(data);
                    return;
                }

                const reason = data.reason || 'Verification failed';
                reportRemoteError('VERIFICATION_FAILED', { reason, details: data.details });

                if (isTerminalRejection(reason)) {
                    isScanning = false;
                    isProcessingScan = false;
                    showError(reason);
                    return;
                }

                // Non-terminal: keep listening. Barcode scanners can stream partial/overlapping payloads.
                resumeListening(verifyOnlyMode ? 'LISTENING: Focus on the barcode…' : 'LISTENING: Scan again (need DBB + DAQ)');
            } catch (e) {
                reportRemoteError('FETCH_EXCEPTION', { message: e.message, stack: e.stack });
                if (verifyOnlyMode) {
                    resumeListening(`NETWORK: ${e.message}. Scan again.`);
                    return;
                }

                isScanning = false;
                isProcessingScan = false;
                showError(`Network Error: ${e.message}`);
            } finally {
                if (!isScanning) {
                    btnScanNow.style.opacity = "1";
                    btnScanNow.style.pointerEvents = "auto";
                }
            }
        }

        async function reportRemoteError(type, details, diagType = 'CLIENT_ERROR') {
            try {
                if (diagType === 'CLIENT_LOG' && !remoteTelemetryEnabled) return;
                const safeDetails = (() => {
                    try {
                        if (!details) return { clientSessionId };
                        if (typeof details === 'object') return { ...details, clientSessionId };
                        return { value: String(details), clientSessionId };
                    } catch (e) {
                        return { clientSessionId };
                    }
                })();

                await fetch('/api/debug/client-errors', {
                    method: 'POST',
                    headers: getApiHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify({
                        type: diagType,
                        error: type,
                        details: safeDetails,
                        userAgent: navigator.userAgent,
                        saleId: saleId
                    })
                });
            } catch (err) {
                console.error('Failed to report remote error:', err);
            }
        }

        function showTenderChoiceAfterScan() {
            // Hide scan UI (still keep debug/preview visible for now).
            try { btnScanNow.style.display = 'none'; } catch (e) { }

            // Show tender selection.
            if (tenderBox) tenderBox.style.display = 'block';
            const title = document.getElementById('mainTitle');
            const subtitle = document.getElementById('mainSubtitle');
            if (title) title.textContent = 'Choose Tender';
            if (subtitle) subtitle.textContent = 'Tap Cash or Card, then return to POS.';

            // Make buttons just return to POS (no cash calculator, no sale closing).
            if (btnCash) {
                btnCash.onclick = () => {
                    clientLog('postScan tender selected', { tender: 'cash' });
                    closeGateway();
                };
            }
            if (btnCard) {
                btnCard.onclick = () => {
                    clientLog('postScan tender selected', { tender: 'card' });
                    closeGateway();
                };
            }
        }

        function showSuccess(data) {
            try {
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
            } catch (e) { }

            // Make the success popup look clean: hide the scan capture UI (input + preview)
            // so staff don't see any masked characters/caret behind the overlay.
            try { if (scanNowWrap) scanNowWrap.style.display = 'none'; } catch (e) { }
            try { if (ghostInput) { ghostInput.blur(); ghostInput.value = ''; } } catch (e) { }
            try { const p = document.getElementById('scanPreviewText'); if (p) p.textContent = '...'; } catch (e) { }

            document.getElementById('successOverlay').classList.add('active');
            latestVerificationId = data.verificationId || data.verification_id || latestVerificationId;
            document.getElementById('successMsg').textContent = `Age: ${data.age ?? '??'}`;
            try {
                const nameEl = document.getElementById('successName');
                if (nameEl) {
                    // For now, only show Age on the verify popup (no name).
                    nameEl.textContent = '';
                    nameEl.style.display = 'none';
                }
            } catch (e) { }
            const detailsEl = document.getElementById('successDetails');
            const isDebugUi = document.body.classList.contains('debug-ui');

            // Make it obvious whether the scan actually saved anything to Lightspeed (without showing PII).
            // Use a 0ms timeout so this runs after any existing debug formatting below.
            const applyCustomerSaveHint = () => {
                if (!detailsEl) return;

                // Verify-only popup should be minimal: only Age + Name.
                if (verifyOnlyMode) {
                    detailsEl.style.display = 'none';
                    detailsEl.textContent = '';
                    return;
                }

                if (isDebugUi) {
                    detailsEl.style.display = 'block';
                    return;
                }

                let msg = '';
                if (!data.saleCustomerId) {
                    msg = 'Customer not linked — attach loyalty customer first (phone number), then scan.';
                } else if (data.customerUpdated) {
                    msg = 'Customer profile saved in Lightspeed.';
                } else if (data.customerUpdateSkipped === 'no_blank_fields') {
                    msg = 'Customer already has info on file.';
                } else if (data.customerUpdateSkipped === 'writes_disabled') {
                    msg = 'Customer save disabled (server config).';
                } else if (data.customerUpdateSkipped) {
                    const code = data.customerUpdateStatus ? ` (${data.customerUpdateStatus})` : '';
                    msg = `Customer save failed${code}.`;
                }

                if (msg) {
                    detailsEl.style.display = 'block';
                    detailsEl.style.marginTop = '8px';
                    detailsEl.style.opacity = '0.8';
                    detailsEl.style.fontSize = '12px';
                    detailsEl.textContent = msg;
                } else {
                    detailsEl.style.display = 'none';
                    detailsEl.textContent = '';
                }
            };
            setTimeout(applyCustomerSaveHint, 0);
            if (detailsEl) {
                if (isDebugUi) {
                    const customerHint = data.saleCustomerId ? 'customer=attached' : 'customer=none';
                    const syncHint = data.customerUpdated
                        ? `synced=${Array.isArray(data.customerUpdatedFields) ? data.customerUpdatedFields.length : 1}`
                        : `synced=0 (${data.customerUpdateSkipped || 'n/a'})`;
                    detailsEl.textContent = `${customerHint} • ${syncHint} • note=${data.noteUpdated ? 'yes' : 'no'}`;
                } else {
                    detailsEl.textContent = '';
                }
            }
            clientLog('success', {
                age: data.age ?? null,
                noteUpdated: Boolean(data.noteUpdated),
                saleCustomerId: data.saleCustomerId ? 'present' : 'none',
                customerUpdated: Boolean(data.customerUpdated),
                customerUpdateSkipped: data.customerUpdateSkipped || null
            });

            document.getElementById('btnContinue').onclick = () => {
                if (verifyOnlyMode) {
                    closeGateway();
                    return;
                }

                if (selectedTender === 'cash') {
                    document.getElementById('successOverlay').classList.remove('active');
                    showCashCalculator();
                } else {
                    finishCardFlow();
                }
            };

            if (verifyOnlyMode) {
                // Stop any scanning/focus loops once verified.
                isScanning = false;
                isProcessingScan = false;
                scanLocked = true;
                try { visualRoot.classList.remove('scanning'); } catch (e) { }

                const btn = document.getElementById('btnContinue');
                if (btn) btn.style.display = 'none';

                if (postScanTenderChoice) {
                    document.getElementById('successOverlay').classList.remove('active');
                    showTenderChoiceAfterScan();
                    return;
                }

                setTimeout(() => {
                    closeGateway();
                }, 1250);
            }
        }

        function showError(msg) {
            document.getElementById('errorOverlay').classList.add('active');
            document.getElementById('errorMsg').textContent = msg;
            document.getElementById('debugStatus').textContent = 'ERROR: ' + msg;
        }

        function resetUI() {
            // Hide overlays
            document.getElementById('errorOverlay').classList.remove('active');
            document.getElementById('successOverlay').classList.remove('active');
            try { if (scanNowWrap) scanNowWrap.style.display = ''; } catch (e) { }

            // Reset scan button
            isScanning = false;
            visualRoot.classList.remove('scanning');
            setIdleScanButtonText();
            btnScanNow.style.opacity = "1";
            btnScanNow.style.pointerEvents = "auto";
            resetScanCaptureState();
            document.getElementById('debugStatus').textContent = 'SYSTEM READY';

            // Re-show main controls
            if (tenderBox) tenderBox.classList.remove('hidden');
            if (btnScanNow) btnScanNow.classList.remove('hidden');

            // Ensure ghost input is ready
            try { ghostInput.disabled = false; } catch (e) { }
            focusGhostInput('resetUI');
        }

        function formatMoney(amount) {
            const value = Number.isFinite(amount) ? amount : 0;
            return `$${value.toFixed(2)}`;
        }

        function computeQuickCashOptions(total) {
            const safeTotal = Number.isFinite(total) ? total : 0;
            const exact = safeTotal;

            const isWhole = Math.abs(safeTotal - Math.round(safeTotal)) < 0.00001;
            const nextDollar = isWhole ? (Math.round(safeTotal) + 1) : Math.ceil(safeTotal);
            const nextFive = Math.ceil(nextDollar / 5) * 5;

            return {
                exact,
                nextDollar,
                nextFive: Math.max(nextFive, nextDollar)
            };
        }

        function setCashReceived(amount) {
            const safe = Number.isFinite(amount) ? amount : 0;
            receivedAmountStr = safe.toFixed(2);
            updateCashDisplay();
        }

        // Cash Calculator Logic
        function showCashCalculator() {
            mainWrap.classList.add('hidden');
            cashWrap.style.display = 'block';
            document.getElementById('dispSaleTotal').textContent = formatMoney(saleAmount);
            clearMoney();

            const options = computeQuickCashOptions(saleAmount);
            if (btnQuickExact) {
                btnQuickExact.textContent = formatMoney(options.exact);
                btnQuickExact.onclick = () => setCashReceived(options.exact);
            }
            if (btnQuickNextDollar) {
                btnQuickNextDollar.textContent = formatMoney(options.nextDollar);
                btnQuickNextDollar.onclick = () => setCashReceived(options.nextDollar);
            }
            if (btnQuickNextFive) {
                btnQuickNextFive.textContent = formatMoney(options.nextFive);
                btnQuickNextFive.onclick = () => setCashReceived(options.nextFive);
            }
        }

        function addMoney(val) {
            if (val === '.' && receivedAmountStr.includes('.')) return;
            receivedAmountStr += val;
            updateCashDisplay();
        }

        function backspaceMoney() {
            if (!receivedAmountStr) return;
            receivedAmountStr = receivedAmountStr.slice(0, -1);
            updateCashDisplay();
        }

        function clearMoney() {
            receivedAmountStr = "";
            updateCashDisplay();
        }

        function updateCashDisplay() {
            const val = parseFloat(receivedAmountStr || "0");
            document.getElementById('dispReceived').textContent = `$${val.toFixed(2)}`;

            const change = Math.round((val - saleAmount) * 100) / 100;
            if (change >= 0 && val > 0) {
                document.getElementById('changeBox').classList.remove('hidden');
                document.getElementById('dispChange').textContent = `$${change.toFixed(2)}`;
            } else {
                document.getElementById('changeBox').classList.add('hidden');
            }
        }

        if (btnCompleteSale) {
            btnCompleteSale.onclick = async () => {
                if (!saleId) {
                    showError('Missing Sale ID (Reload from POS)');
                    return;
                }

                if (!latestVerificationId) {
                    showError('Missing verification ID. Please rescan the ID.');
                    return;
                }

                const val = parseFloat(receivedAmountStr);
                if (!Number.isFinite(val) || val <= 0) {
                    showError('Enter cash received.');
                    return;
                }

                const total = Math.round(saleAmount * 100) / 100;
                const received = Math.round(val * 100) / 100;
                const change = Math.round((received - total) * 100) / 100;

                const originalLabel = btnCompleteSale.textContent;
                btnCompleteSale.textContent = 'Processing...';
                btnCompleteSale.disabled = true;

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 20000);

                try {
                    const res = await fetch(`/api/sales/${encodeURIComponent(saleId)}/complete`, {
                        method: 'POST',
                        headers: getApiHeaders({ 'Content-Type': 'application/json' }),
                        signal: controller.signal,
                        body: JSON.stringify({
                            verificationId: latestVerificationId,
                            paymentType: 'cash',
                            saleTotal: total,
                            cashReceived: received,
                            changeGiven: change
                        })
                    });

                    const payload = await res.json().catch(() => ({}));
                    if (!res.ok) {
                        const msg = payload.message || payload.error || res.statusText;
                        throw new Error(msg);
                    }

                    // Prefer the documented Lightspeed Payments API exit step (closes modal/dialog in X-Series).
                    const didClose = (() => {
                        if (!lightspeedTargetOrigin) return false;
                        if (selectedTender === 'cash' && lsCashMode === 'accept') {
                            const ok = lsAccept({ amount: saleAmount, print: false });
                            // Some embedded environments don't auto-close on ACCEPT; follow with EXIT to force close.
                            setTimeout(() => { try { lsExit(); } catch (e) { } }, 400);
                            return ok;
                        }
                        if (lsCloseMode === 'decline') {
                            return lsDecline({ print: false });
                        }
                        return lsExit();
                    })();

                    if (!didClose) {
                        window.parent.postMessage('ACCEPT', '*');
                        window.parent.postMessage('CLOSE', '*');
                        window.parent.postMessage('EXIT', '*');
                    }

                    // If the container doesn't respond, show the Return-to-POS helper overlay.
                    setTimeout(() => {
                        const overlay = document.getElementById('closeOverlay');
                        if (overlay) overlay.classList.add('active');
                    }, 900);
                } catch (e) {
                    reportRemoteError('CASH_COMPLETE_FAILED', { message: e.message, verificationId: latestVerificationId });
                    showError(`Cash completion failed: ${e.message}`);
                    btnCompleteSale.textContent = originalLabel;
                    btnCompleteSale.disabled = false;
                    return;
                } finally {
                    clearTimeout(timeout);
                }
            };
        }

        function finishCardFlow() {
            // Signal for card tender: exit/close so POS can take over
            // For Lightspeed Payments API, prefer EXIT (closes modal) over DECLINE (returns to pay screen with a decline state).
            // This stable gateway is intended to *not* close the sale; always return to the pay screen.
            const didClose = lsDecline({ print: false });

            if (!didClose) {
                window.parent.postMessage('CLOSE', '*');
                window.parent.postMessage('EXIT', '*');
                window.parent.postMessage('DECLINE', '*');
            }
        }

        function closeGateway() {
            // Show a manual fallback in case Lightspeed ignores close messages in this embed context.
            setTimeout(() => {
                const overlay = document.getElementById('closeOverlay');
                if (overlay) overlay.classList.add('active');
            }, 900);

            // Scan-only: close the gateway dialog and return to the sell/pay screen without marking the payment declined.
            // Using DECLINE shows a red "payment declined" state in POS; EXIT is the clean close/unbind step.
            const didClose = lsExit();

            // In embedded (Lightspeed) mode, do not attempt browser navigation/window close; it can break the webview.
            if (embeddedMode) return;

            if (!didClose) {
                tryCloseWindow();
                try { window.history.back(); } catch (e) { }
            }
        }

        // Auto-detect refund
        if (saleAmount < 0) {
            if (!lsExit()) {
                window.parent.postMessage('ACCEPT', '*');
            }
        } </script>
</body>

</html>

